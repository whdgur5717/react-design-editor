{
	"master": {
		"tasks": [
			{
				"id": "1",
				"title": "Undo/Redo 시스템 구현",
				"description": "모든 편집 작업에 대한 실행 취소/재실행 기능을 구현하여 에디터의 기본 UX를 완성합니다.",
				"details": "Zustand 미들웨어를 활용하여 히스토리 스택 기반 Undo/Redo를 구현합니다.\n\n**구현 방법:**\n1. `packages/editor-shell/src/store/history.ts` 생성\n2. Zustand의 `temporal` 미들웨어 패턴 적용 또는 커스텀 히스토리 미들웨어 작성\n3. 상태 변경마다 스냅샷 저장 (document, components, selection)\n4. `undo()`, `redo()`, `canUndo()`, `canRedo()` 액션 추가\n5. 키보드 단축키 연결: Cmd/Ctrl+Z (undo), Cmd/Ctrl+Shift+Z (redo)\n\n**기술 선택:**\n- `zustand/middleware` 의 temporal 패턴 참고\n- 또는 직접 구현: `history: { past: EditorState[], future: EditorState[] }`\n- 성능 최적화: 최대 50개 히스토리 유지, 깊은 복사 최소화\n\n**의사 코드:**\n```typescript\ninterface HistoryState {\n  past: EditorState[]\n  future: EditorState[]\n}\n\nconst historyMiddleware = (config) => (set, get, api) => {\n  const setState = (...args) => {\n    const currentState = get()\n    const past = [...currentState.past, currentState].slice(-50)\n    set({ past, future: [] })\n    set(...args)\n  }\n  \n  const undo = () => {\n    const { past, future } = get()\n    if (past.length === 0) return\n    const previous = past[past.length - 1]\n    set({ \n      ...previous,\n      past: past.slice(0, -1),\n      future: [get(), ...future]\n    })\n  }\n  \n  return config(setState, get, api)\n}\n```",
				"testStrategy": "**테스트 전략:**\n1. 유닛 테스트: `packages/editor-shell/src/store/__tests__/history.test.ts`\n   - 상태 변경 후 undo 시 이전 상태 복원 확인\n   - redo 시 다음 상태 복원 확인\n   - canUndo/canRedo 플래그 정확성\n2. 통합 테스트:\n   - 노드 추가 → undo → redo 시나리오\n   - 여러 작업 후 연속 undo → redo\n   - 히스토리 최대 크기 제한 동작\n3. E2E 테스트 (Playwright):\n   - 캔버스에서 노드 이동 후 Cmd+Z로 복원\n   - 복잡한 편집 시나리오 (추가/삭제/이동 혼합)",
				"priority": "high",
				"dependencies": [],
				"status": "done",
				"subtasks": [
					{
						"id": 1,
						"title": "히스토리 미들웨어 타입 정의 및 기본 구조 설계",
						"description": "EditorState의 히스토리 추적을 위한 타입 정의와 미들웨어 구조를 설계합니다. Zustand의 미들웨어 패턴을 활용하여 상태 스냅샷을 관리할 수 있는 기반을 마련합니다.",
						"dependencies": [],
						"details": "**구현 내용:**\n1. `packages/editor-core/src/types/history.ts` 생성\n   - `HistoryState` 인터페이스 정의: `past: EditorState[]`, `future: EditorState[]`\n   - `HistoryActions` 인터페이스 정의: `undo()`, `redo()`, `canUndo()`, `canRedo()`\n   - 히스토리 설정 인터페이스: `HistoryConfig` (maxHistorySize, equalityFn)\n\n2. `editor.ts`의 `EditorStore` 타입 확장\n   - `EditorStore`에 `HistoryState` & `HistoryActions` 추가\n\n**타입 정의 예시:**\n```typescript\nexport interface HistoryState {\n  past: EditorState[]\n  future: EditorState[]\n}\n\nexport interface HistoryActions {\n  undo: () => void\n  redo: () => void\n  canUndo: () => boolean\n  canRedo: () => boolean\n}\n\nexport interface HistoryConfig {\n  maxHistorySize?: number // 기본값: 50\n  equalityFn?: (a: EditorState, b: EditorState) => boolean\n}\n```\n\n**참고:**\n- 기존 `EditorState` (editor.ts:11-29)는 document, components, selection, hoveredId, activeTool, zoom을 포함\n- `EditorStore`는 `EditorState & EditorActions`로 정의되어 있음 (editor.ts:103)",
						"status": "done",
						"testStrategy": "타입 정의는 TypeScript 컴파일 체크로 검증합니다.\n- `pnpm type-check` 실행 시 에러가 없어야 함\n- `HistoryState`, `HistoryActions`, `HistoryConfig`가 올바르게 export되는지 확인\n- 순환 참조나 타입 충돌이 없는지 확인",
						"parentId": "undefined"
					},
					{
						"id": 2,
						"title": "히스토리 미들웨어 구현",
						"description": "Zustand 스토어를 래핑하여 상태 변경을 자동으로 추적하고 히스토리 스택에 저장하는 미들웨어를 구현합니다. 성능 최적화를 위해 최대 50개의 히스토리만 유지합니다.",
						"dependencies": [1],
						"details": "**구현 내용:**\n1. `packages/editor-shell/src/store/middleware/history.ts` 생성\n2. `historyMiddleware` 함수 작성\n   - Zustand의 `StateCreator` 타입을 활용한 미들웨어 패턴\n   - 상태 변경 감지 시 이전 상태를 past 배열에 추가\n   - 최대 50개 히스토리 유지 (FIFO)\n   - 새로운 변경 발생 시 future 배열 초기화\n\n**핵심 로직:**\n```typescript\nimport type { StateCreator, StoreMutatorIdentifier } from 'zustand'\nimport type { EditorState, HistoryState, HistoryActions } from '@design-editor/core'\n\ntype HistoryMiddleware = <\n  T extends EditorState,\n  Mps extends [StoreMutatorIdentifier, unknown][] = [],\n  Mcs extends [StoreMutatorIdentifier, unknown][] = []\n>(\n  config: StateCreator<T, Mps, Mcs>\n) => StateCreator<T & HistoryState, Mps, Mcs>\n\nexport const historyMiddleware: HistoryMiddleware = (config) => (set, get, api) => {\n  const MAX_HISTORY = 50\n  \n  return {\n    ...config(\n      (args) => {\n        const currentState = get() as EditorState\n        const snapshot = {\n          document: currentState.document,\n          components: currentState.components,\n          selection: currentState.selection,\n          hoveredId: currentState.hoveredId,\n          activeTool: currentState.activeTool,\n          zoom: currentState.zoom,\n        }\n        \n        set((state: any) => ({\n          past: [...state.past, snapshot].slice(-MAX_HISTORY),\n          future: [],\n        }))\n        \n        set(args)\n      },\n      get,\n      api\n    ),\n    past: [],\n    future: [],\n  }\n}\n```\n\n**주의사항:**\n- hoveredId 변경은 히스토리에 포함하지 않도록 필터링 필요\n- 깊은 복사 대신 구조적 공유로 메모리 최적화",
						"status": "done",
						"testStrategy": "**유닛 테스트:** `packages/editor-shell/src/store/middleware/__tests__/history.test.ts`\n1. 상태 변경 시 past 배열에 스냅샷 추가 확인\n2. 새로운 변경 시 future 배열 초기화 확인\n3. 최대 50개 히스토리 제한 동작 확인 (51번째 변경 시 가장 오래된 항목 제거)\n4. hoveredId 변경은 히스토리에 추가되지 않음 확인",
						"parentId": "undefined"
					},
					{
						"id": 3,
						"title": "Undo/Redo 액션 구현",
						"description": "히스토리 스택을 사용하여 이전 상태로 되돌리거나 다시 실행하는 undo/redo 액션을 구현합니다. canUndo/canRedo 헬퍼 함수도 함께 제공합니다.",
						"dependencies": [2],
						"details": "**구현 내용:**\n1. `editor.ts`의 스토어에 히스토리 액션 추가\n2. `undo()` 구현:\n   - past 배열에서 마지막 상태를 pop\n   - 현재 상태를 future 배열에 push\n   - past의 마지막 상태로 복원\n3. `redo()` 구현:\n   - future 배열에서 첫 번째 상태를 shift\n   - 현재 상태를 past 배열에 push\n   - future의 첫 번째 상태로 복원\n4. `canUndo()`, `canRedo()` 헬퍼 함수\n\n**액션 코드 예시:**\n```typescript\n// editor.ts의 create 함수 내부에 추가\nundo() {\n  const state = get()\n  if (state.past.length === 0) return\n  \n  const previous = state.past[state.past.length - 1]\n  const currentSnapshot = {\n    document: state.document,\n    components: state.components,\n    selection: state.selection,\n    hoveredId: state.hoveredId,\n    activeTool: state.activeTool,\n    zoom: state.zoom,\n  }\n  \n  set({\n    ...previous,\n    past: state.past.slice(0, -1),\n    future: [currentSnapshot, ...state.future],\n  })\n},\n\nredo() {\n  const state = get()\n  if (state.future.length === 0) return\n  \n  const next = state.future[0]\n  const currentSnapshot = {\n    document: state.document,\n    components: state.components,\n    selection: state.selection,\n    hoveredId: state.hoveredId,\n    activeTool: state.activeTool,\n    zoom: state.zoom,\n  }\n  \n  set({\n    ...next,\n    past: [...state.past, currentSnapshot],\n    future: state.future.slice(1),\n  })\n},\n\ncanUndo: () => get().past.length > 0,\ncanRedo: () => get().future.length > 0,\n```\n\n**주의사항:**\n- 상태 복원 시 Canvas와의 동기화는 기존 subscribe 메커니즘이 자동 처리 (App.tsx:60-67)",
						"status": "done",
						"testStrategy": "**유닛 테스트:** `packages/editor-shell/src/store/__tests__/undo-redo.test.ts`\n1. 노드 추가 → undo → 노드가 제거되고 이전 상태로 복원됨\n2. 노드 스타일 변경 → undo → 이전 스타일로 복원됨\n3. undo 후 redo → 다시 변경된 상태로 복원됨\n4. 여러 작업 후 연속 undo → 각 단계별로 정확히 복원됨\n5. canUndo()가 past.length > 0일 때만 true 반환\n6. canRedo()가 future.length > 0일 때만 true 반환\n7. undo 불가능한 상태에서 undo 호출 → 아무 일도 발생하지 않음",
						"updatedAt": "2026-01-30T11:56:46.164Z",
						"parentId": "undefined"
					},
					{
						"id": 4,
						"title": "키보드 단축키 연결 (Cmd/Ctrl+Z, Cmd/Ctrl+Shift+Z)",
						"description": "기존 키보드 단축키 훅에 Undo/Redo 단축키를 추가합니다. Cmd+Z로 실행 취소, Cmd+Shift+Z로 재실행이 가능하도록 구현합니다.",
						"dependencies": [3],
						"details": "**구현 내용:**\n1. `packages/editor-shell/src/hooks/useKeyboardShortcuts.ts` 수정\n2. 기존 단축키 핸들러에 undo/redo 로직 추가\n3. Cmd/Ctrl+Z: `undo()` 호출\n4. Cmd/Ctrl+Shift+Z: `redo()` 호출\n5. Windows/Linux에서는 Ctrl+Z, Ctrl+Y도 지원 고려\n\n**코드 수정 예시:**\n```typescript\n// useKeyboardShortcuts.ts 내부\nconst undo = useEditorStore((state) => state.undo)\nconst redo = useEditorStore((state) => state.redo)\nconst canUndo = useEditorStore((state) => state.canUndo)\nconst canRedo = useEditorStore((state) => state.canRedo)\n\nuseEffect(() => {\n  const handleKeyDown = (e: KeyboardEvent) => {\n    // ... 기존 코드 ...\n    \n    const isMeta = e.metaKey || e.ctrlKey\n    \n    // Cmd/Ctrl+Z: Undo\n    if (isMeta && e.key === 'z' && !e.shiftKey) {\n      e.preventDefault()\n      if (canUndo()) {\n        undo()\n      }\n    }\n    \n    // Cmd/Ctrl+Shift+Z: Redo (Mac)\n    // Cmd/Ctrl+Y: Redo (Windows/Linux)\n    if ((isMeta && e.key === 'z' && e.shiftKey) || (isMeta && e.key === 'y')) {\n      e.preventDefault()\n      if (canRedo()) {\n        redo()\n      }\n    }\n  }\n  \n  // ... 기존 코드 ...\n}, [document, selection, setSelection, removeNode, duplicateNode, undo, redo, canUndo, canRedo])\n```\n\n**참고:**\n- 기존 단축키 구현 패턴 유지 (useKeyboardShortcuts.ts:26-75)\n- input/textarea에서는 단축키 무시 (useKeyboardShortcuts.ts:36-39)",
						"status": "done",
						"testStrategy": "**통합 테스트:**\n1. 수동 테스트로 키보드 동작 확인\n   - 노드 추가 후 Cmd+Z → 노드 제거 확인\n   - Cmd+Shift+Z → 노드 다시 추가 확인\n   - input 필드 포커스 시 Cmd+Z가 에디터에 영향 주지 않음 확인\n\n**E2E 테스트:** `playwright/**/*.test.ts`\n1. Canvas에서 노드 추가 → Cmd+Z 입력 → 노드가 사라짐\n2. Cmd+Shift+Z 입력 → 노드가 다시 나타남\n3. 여러 작업 후 연속 Cmd+Z → 각 작업이 역순으로 취소됨",
						"parentId": "undefined",
						"updatedAt": "2026-01-30T11:56:47.899Z"
					},
					{
						"id": 5,
						"title": "히스토리 미들웨어 통합 및 최적화",
						"description": "구현한 히스토리 미들웨어를 실제 에디터 스토어에 적용하고, hoveredId와 같은 일시적 상태 변경을 히스토리에서 제외하는 최적화를 수행합니다.",
						"dependencies": [4],
						"details": "**구현 내용:**\n1. `editor.ts`의 `create` 함수에 히스토리 미들웨어 적용\n2. hoveredId 변경은 히스토리 추적에서 제외\n3. 성능 최적화:\n   - 동일한 상태 연속 변경 시 중복 스냅샷 방지\n   - debounce 패턴 적용 고려 (드래그 중 연속 moveNode 호출)\n4. 통합 테스트 및 버그 수정\n\n**미들웨어 적용 예시:**\n```typescript\n// editor.ts\nimport { create } from 'zustand'\nimport { historyMiddleware } from './middleware/history'\n\nexport const useEditorStore = create<EditorStore>()((\n  historyMiddleware(\n    (set, get) => ({\n      // 기존 초기 상태\n      document: initialDocument,\n      components: [],\n      selection: [],\n      hoveredId: null,\n      activeTool: 'select',\n      zoom: 1,\n      \n      // 기존 액션들...\n      updateNode(id: string, updates: Partial<NodeData>) {\n        set((state) => ({\n          document: updateNodeInTree(state.document, id, updates) as DocumentNode,\n        }))\n      },\n      \n      // ... 나머지 액션들 ...\n    })\n  )\n))\n```\n\n**히스토리 제외 로직:**\n```typescript\n// hoveredId 변경 시 히스토리에 추가하지 않도록 수정\nsetHoveredId(id: string | null) {\n  // 히스토리 미들웨어를 우회하는 플래그 또는 별도 처리\n  set({ hoveredId: id }, false, 'setHoveredId/noHistory')\n},\n```\n\n**드래그 최적화 (선택적):**\n- moveNode 호출 시 debounce 적용하여 드래그 완료 시점에만 히스토리 저장\n- 또는 `onNodeMoved` 완료 시점에 히스토리 기록\n\n**검증 항목:**\n- 모든 기존 기능이 정상 동작하는지 확인\n- Canvas 동기화가 undo/redo 후에도 올바르게 작동하는지 확인\n- 메모리 누수 없는지 확인 (개발자 도구 프로파일링)",
						"status": "done",
						"testStrategy": "**통합 테스트:**\n1. 전체 에디터 워크플로우 테스트\n   - 노드 추가/삭제/이동/리사이즈 → undo/redo → 모든 작업이 올바르게 복원됨\n   - 컴포넌트 생성/인스턴스 추가 → undo/redo → 컴포넌트 상태 복원 확인\n2. 성능 테스트\n   - 50개 이상 작업 수행 → 히스토리 크기가 50개로 제한됨\n   - 빠른 연속 드래그 → 히스토리가 과도하게 쌓이지 않음\n3. 엣지 케이스\n   - Canvas iframe 재연결 후 undo/redo 동작 확인\n   - hoveredId 변경 후 undo → hoveredId는 복원되지 않고 document만 복원됨\n\n**E2E 테스트:**\n- 실제 사용 시나리오 (노드 생성 → 스타일 변경 → 이동 → undo 3회 → redo 2회)\n- 브라우저 새로고침 후에도 정상 동작 (히스토리는 초기화됨)",
						"parentId": "undefined",
						"updatedAt": "2026-01-30T11:56:49.572Z"
					}
				],
				"updatedAt": "2026-01-30T11:56:49.572Z"
			},
			{
				"id": "2",
				"title": "컴포넌트/인스턴스 codegen 지원",
				"description": "현재 serialize.ts가 일반 노드만 처리하므로, ComponentDefinition과 InstanceNode를 JSX로 변환하는 로직을 추가합니다.",
				"details": "**현재 상태:**\n- `serialize.ts`는 NodeData만 처리\n- InstanceNode (`type: '__INSTANCE__'`)와 ComponentDefinition 미지원\n\n**구현 방법:**\n1. `packages/editor-core/src/codegen/serialize.ts` 수정\n2. `serializeNodeInternal`에서 `type === '__INSTANCE__'` 분기 추가\n3. InstanceNode 처리:\n   - componentId로 ComponentDefinition 조회\n   - root 노드를 재귀 렌더링\n   - overrides 적용 (해당 nodeId의 props/style/children 덮어쓰기)\n4. ComponentDefinition 전체 export:\n   - `serializeComponent(component: ComponentDefinition)` 함수 추가\n   - 컴포넌트 이름으로 함수 생성\n\n**의사 코드:**\n```typescript\nfunction serializeNodeInternal(node: NodeData, options, depth, components: ComponentDefinition[]) {\n  if (node.type === '__INSTANCE__') {\n    const instance = node as InstanceNode\n    const component = components.find(c => c.id === instance.componentId)\n    if (!component) return '/* Component not found */'\n    \n    // root를 복제하고 overrides 적용\n    const resolvedRoot = applyOverrides(component.root, instance.overrides)\n    return serializeNodeInternal(resolvedRoot, options, depth, components)\n  }\n  \n  // 기존 로직...\n}\n\nfunction applyOverrides(node: NodeData, overrides?: Record<string, any>): NodeData {\n  if (!overrides || !overrides[node.id]) return node\n  const override = overrides[node.id]\n  return {\n    ...node,\n    props: { ...node.props, ...override.props },\n    style: { ...node.style, ...override.style },\n    children: override.children ?? node.children\n  }\n}\n\nfunction serializeComponent(component: ComponentDefinition, options): string {\n  const jsx = serializeNode(component.root, options)\n  return `export function ${component.name}() {\\n  return (\\n${jsx}\\n  );\\n}`\n}\n```",
				"testStrategy": "**테스트 전략:**\n1. 유닛 테스트: `packages/editor-core/src/codegen/__tests__/serialize-component.test.ts`\n   - 단순 컴포넌트 정의 → JSX 변환\n   - 인스턴스 → 컴포넌트 root 렌더링\n   - 오버라이드 적용 (props, style, children)\n2. 스냅샷 테스트:\n   - 복잡한 컴포넌트/인스턴스 트리 → 예상 JSX 코드 비교\n3. 통합 테스트:\n   - 에디터에서 컴포넌트 생성 → 인스턴스 추가 → 코드 프리뷰에서 올바른 JSX 확인",
				"priority": "high",
				"dependencies": ["1"],
				"status": "deferred",
				"subtasks": [],
				"updatedAt": "2026-01-30T12:23:44.128Z"
			},
			{
				"id": "3",
				"title": "실시간 코드 프리뷰 패널 구현",
				"description": "선택한 노드의 JSX 코드를 우측 패널에 실시간으로 표시하고 복사 기능을 제공합니다.",
				"details": "**UI 위치:** 우측 패널에 탭 형태로 추가 (Properties / Code)\n\n**구현 방법:**\n1. `packages/editor-shell/src/components/CodePreviewPanel.tsx` 생성\n2. 선택된 노드 ID를 감시하여 실시간 코드 생성\n   - `const selectedNode = useEditorStore(state => findNode(state.document, state.selection[0]))`\n   - `const code = serializeNode(selectedNode, { indent: '  ' })`\n3. Syntax highlighting: `react-syntax-highlighter` 또는 `prism-react-renderer` 사용\n4. 복사 버튼: `navigator.clipboard.writeText(code)`\n5. 다중 선택 시 처리:\n   - 단일 선택: 해당 노드만\n   - 다중 선택: 공통 부모로 감싸서 표시\n   - 선택 없음: 전체 document\n\n**의사 코드:**\n```tsx\nimport { Prism as SyntaxHighlighter } from 'react-syntax-highlighter'\nimport { vscDarkPlus } from 'react-syntax-highlighter/dist/esm/styles/prism'\n\nexport function CodePreviewPanel() {\n  const selection = useEditorStore(state => state.selection)\n  const document = useEditorStore(state => state.document)\n  const components = useEditorStore(state => state.components)\n  \n  const code = useMemo(() => {\n    if (selection.length === 0) {\n      return serializeDocument(document, 'Component')\n    }\n    if (selection.length === 1) {\n      const node = findNode(document, selection[0])\n      return node ? serializeNode(node, { components }) : ''\n    }\n    // 다중 선택: Fragment로 감싸기\n    const nodes = selection.map(id => findNode(document, id)).filter(Boolean)\n    return `<>\\n${nodes.map(n => serializeNode(n)).join('\\n')}\\n</>`\n  }, [selection, document, components])\n  \n  const handleCopy = () => {\n    navigator.clipboard.writeText(code)\n    toast.success('Copied to clipboard')\n  }\n  \n  return (\n    <div className=\"code-preview\">\n      <div className=\"toolbar\">\n        <button onClick={handleCopy}>Copy</button>\n      </div>\n      <SyntaxHighlighter language=\"tsx\" style={vscDarkPlus}>\n        {code}\n      </SyntaxHighlighter>\n    </div>\n  )\n}\n```",
				"testStrategy": "**테스트 전략:**\n1. 컴포넌트 테스트:\n   - 노드 선택 시 올바른 JSX 표시\n   - 복사 버튼 클릭 시 클립보드에 코드 복사\n2. E2E 테스트:\n   - 캔버스에서 노드 선택 → 코드 패널에 즉시 반영\n   - 스타일 변경 → 코드 실시간 업데이트\n   - 다중 선택 → Fragment 래핑 확인",
				"priority": "medium",
				"dependencies": ["2"],
				"status": "deferred",
				"subtasks": [],
				"updatedAt": "2026-01-30T12:23:45.674Z"
			},
			{
				"id": "4",
				"title": "Variant 데이터 모델 및 타입 정의",
				"description": "ComponentDefinition에 Variant 정보를 저장할 수 있도록 타입과 데이터 구조를 확장합니다.",
				"details": "**Variant 시스템 설계:**\n- Variant Property: 하나의 속성 (예: size, state)\n- Variant Option: 각 속성의 가능한 값 (예: sm/md/lg, default/hover/disabled)\n- Variant Combination: 속성 조합에 대한 스타일 오버라이드\n\n**구현 방법:**\n1. `packages/editor-core/src/types/variant.ts` 생성\n2. ComponentDefinition 인터페이스 확장\n3. InstanceNode에 선택된 variant 정보 추가\n\n**타입 정의:**\n```typescript\n// variant.ts\nexport interface VariantProperty {\n  name: string // 'size', 'state'\n  options: string[] // ['sm', 'md', 'lg']\n  defaultValue: string // 'md'\n}\n\nexport interface VariantOverride {\n  // 조합 조건: { size: 'lg', state: 'hover' }\n  condition: Record<string, string>\n  // 해당 조건일 때 적용할 노드별 오버라이드\n  overrides: {\n    [nodeId: string]: {\n      props?: Record<string, unknown>\n      style?: CSSProperties\n    }\n  }\n}\n\nexport interface VariantConfig {\n  properties: VariantProperty[]\n  overrides: VariantOverride[]\n}\n\n// node.ts에서 ComponentDefinition 확장\nexport interface ComponentDefinition {\n  id: string\n  name: string\n  root: NodeData\n  createdAt: string\n  variants?: VariantConfig // 추가\n}\n\n// InstanceNode 확장\nexport interface InstanceNode extends Omit<NodeData, 'type' | 'children'> {\n  type: '__INSTANCE__'\n  componentId: string\n  overrides?: {...}\n  variantSelection?: Record<string, string> // { size: 'lg', state: 'hover' }\n}\n```\n\n**스토어 액션 추가:**\n```typescript\n// editor.ts\ninterface EditorActions {\n  // ...\n  setComponentVariants: (componentId: string, variants: VariantConfig) => void\n  setInstanceVariant: (instanceId: string, property: string, value: string) => void\n}\n```",
				"testStrategy": "**테스트 전략:**\n1. 타입 체크: TypeScript 컴파일 에러 없이 빌드\n2. 유닛 테스트:\n   - VariantConfig 생성 및 직렬화\n   - Variant 조합 매칭 로직 (`matchVariant(condition, selection)`)\n3. 통합 테스트:\n   - 컴포넌트에 variant 설정 → 저장 → 로드 확인",
				"priority": "high",
				"dependencies": ["2"],
				"status": "deferred",
				"subtasks": [],
				"updatedAt": "2026-01-30T12:23:47.222Z"
			},
			{
				"id": "5",
				"title": "Variant 편집 UI 구현",
				"description": "컴포넌트 에디터에서 Variant property와 option을 추가/편집하고, 각 조합에 대한 스타일을 설정하는 UI를 제공합니다.",
				"details": "**UI 구성:**\n1. 컴포넌트 편집 모드 진입 (더블클릭 또는 Edit Component 버튼)\n2. 좌측 패널에 \"Variants\" 섹션 추가\n3. Variant Property 추가/삭제\n4. 각 Property의 Option 추가/삭제\n5. Variant 조합 선택 → 캔버스에서 해당 조합 프리뷰 → 스타일 편집 → 오버라이드 저장\n\n**구현 방법:**\n1. `packages/editor-shell/src/components/VariantEditor.tsx` 생성\n2. Property 관리:\n   - Input으로 property 이름 입력\n   - Chip 형태로 option 추가 (Enter키로 추가)\n3. Combination 편집:\n   - 모든 property 드롭다운으로 조합 선택\n   - 선택된 조합의 프리뷰 렌더링\n   - 속성 패널에서 스타일 변경 시 해당 조합의 override에 저장\n\n**의사 코드:**\n```tsx\nfunction VariantEditor({ componentId }: { componentId: string }) {\n  const component = useEditorStore(state => \n    state.components.find(c => c.id === componentId)\n  )\n  const setVariants = useEditorStore(state => state.setComponentVariants)\n  \n  const [properties, setProperties] = useState<VariantProperty[]>(\n    component?.variants?.properties ?? []\n  )\n  \n  const addProperty = (name: string, options: string[]) => {\n    const newProp: VariantProperty = { name, options, defaultValue: options[0] }\n    setProperties([...properties, newProp])\n  }\n  \n  const handleSave = () => {\n    setVariants(componentId, { properties, overrides: [] })\n  }\n  \n  return (\n    <div className=\"variant-editor\">\n      <h3>Variant Properties</h3>\n      {properties.map(prop => (\n        <PropertyRow key={prop.name} property={prop} onChange={updateProperty} />\n      ))}\n      <button onClick={() => setShowAddDialog(true)}>Add Property</button>\n      \n      <h3>Variant Combinations</h3>\n      <VariantCombinationSelector \n        properties={properties}\n        onSelect={(combination) => setActiveCombination(combination)}\n      />\n      \n      <button onClick={handleSave}>Save Variants</button>\n    </div>\n  )\n}\n```",
				"testStrategy": "**테스트 전략:**\n1. 컴포넌트 테스트:\n   - Property 추가/삭제\n   - Option 추가/삭제\n   - Default value 설정\n2. E2E 테스트:\n   - Button 컴포넌트 생성 → Variant 추가 (size: sm/md/lg) → 각 조합 프리뷰\n   - 조합 선택 → 스타일 변경 → 저장 → 인스턴스에서 확인",
				"priority": "medium",
				"dependencies": ["4"],
				"status": "deferred",
				"subtasks": [],
				"updatedAt": "2026-01-30T12:23:48.727Z"
			},
			{
				"id": "6",
				"title": "인스턴스 Variant 선택 UI 및 렌더링",
				"description": "컴포넌트 인스턴스에서 Variant 조합을 선택할 수 있는 UI를 제공하고, 선택된 variant에 따라 스타일이 적용되도록 구현합니다.",
				"details": "**UI 위치:** 인스턴스 선택 시 속성 패널 상단에 Variant 선택기 표시\n\n**구현 방법:**\n1. `packages/editor-shell/src/components/InstanceVariantSelector.tsx` 생성\n2. 인스턴스의 componentId로 ComponentDefinition 조회\n3. Variant properties를 드롭다운/버튼 그룹으로 표시\n4. 선택 변경 시 `setInstanceVariant(instanceId, property, value)` 호출\n5. 캔버스 렌더링 시 variant에 맞는 오버라이드 적용\n\n**렌더링 로직:**\n```typescript\n// canvas/src/components/InstanceRenderer.tsx\nfunction InstanceRenderer({ instance }: { instance: InstanceNode }) {\n  const component = useComponent(instance.componentId)\n  if (!component) return null\n  \n  // 1. variantSelection에 맞는 override 찾기\n  const variantOverrides = resolveVariantOverrides(\n    component.variants,\n    instance.variantSelection\n  )\n  \n  // 2. component.root에 variant override 적용\n  const rootWithVariants = applyOverridesToTree(component.root, variantOverrides)\n  \n  // 3. 인스턴스 레벨 overrides 추가 적용\n  const finalRoot = applyOverridesToTree(rootWithVariants, instance.overrides)\n  \n  return <NodeRenderer node={finalRoot} />\n}\n\nfunction resolveVariantOverrides(\n  variants: VariantConfig | undefined,\n  selection: Record<string, string> | undefined\n): Record<string, { props?: any; style?: any }> {\n  if (!variants || !selection) return {}\n  \n  // 모든 override 중 selection과 일치하는 것 찾기\n  const matchingOverrides = variants.overrides.filter(override => {\n    return Object.entries(override.condition).every(\n      ([key, value]) => selection[key] === value\n    )\n  })\n  \n  // 여러 매칭이 있으면 병합 (나중 것이 우선)\n  return matchingOverrides.reduce(\n    (acc, override) => mergeOverrides(acc, override.overrides),\n    {}\n  )\n}\n```",
				"testStrategy": "**테스트 전략:**\n1. 유닛 테스트:\n   - `resolveVariantOverrides` 함수: 다양한 조합 테스트\n   - 부분 매칭, 완전 매칭, 우선순위 테스트\n2. 통합 테스트:\n   - Button 인스턴스 생성 → size 변경 → 캔버스에서 스타일 즉시 반영\n3. E2E 테스트:\n   - 인스턴스 선택 → Variant 드롭다운 변경 → 실시간 프리뷰",
				"priority": "medium",
				"dependencies": ["5"],
				"status": "deferred",
				"subtasks": [],
				"updatedAt": "2026-01-30T12:23:50.268Z"
			},
			{
				"id": "7",
				"title": "Variant codegen 구현",
				"description": "Variant가 있는 컴포넌트를 props 기반 React 컴포넌트로 export하며, 인스턴스는 해당 props를 전달하는 JSX로 변환합니다.",
				"details": "**출력 형태:**\n```tsx\n// 컴포넌트 정의\nexport function Button({ size = 'md', state = 'default' }) {\n  const sizeStyles = {\n    sm: { fontSize: 12, padding: '4px 8px' },\n    md: { fontSize: 14, padding: '8px 16px' },\n    lg: { fontSize: 16, padding: '12px 24px' }\n  }\n  \n  const stateStyles = {\n    default: { backgroundColor: 'blue' },\n    hover: { backgroundColor: 'darkblue' },\n    disabled: { backgroundColor: 'gray', cursor: 'not-allowed' }\n  }\n  \n  return (\n    <button style={{ ...sizeStyles[size], ...stateStyles[state] }}>\n      Click me\n    </button>\n  )\n}\n\n// 인스턴스 사용\n<Button size=\"lg\" state=\"hover\" />\n```\n\n**구현 방법:**\n1. `packages/editor-core/src/codegen/serialize-variant.ts` 생성\n2. ComponentDefinition을 분석하여:\n   - Variant properties → 함수 파라미터\n   - Variant overrides → 조건부 스타일 객체\n3. 인스턴스 serialize 시:\n   - variantSelection → props로 변환\n\n**의사 코드:**\n```typescript\nfunction serializeComponentWithVariants(component: ComponentDefinition): string {\n  const { variants } = component\n  if (!variants || variants.properties.length === 0) {\n    // 일반 컴포넌트\n    return serializeComponent(component)\n  }\n  \n  // 1. 함수 시그니처 생성\n  const params = variants.properties\n    .map(p => `${p.name} = '${p.defaultValue}'`)\n    .join(', ')\n  \n  // 2. 각 property별 스타일 맵 생성\n  const styleMaps = variants.properties.map(prop => {\n    const map = {}\n    prop.options.forEach(option => {\n      // 해당 option일 때의 override 추출\n      const override = findOverrideForCondition(variants.overrides, { [prop.name]: option })\n      map[option] = override?.style ?? {}\n    })\n    return `const ${prop.name}Styles = ${JSON.stringify(map, null, 2)}`\n  })\n  \n  // 3. JSX에 조건부 스타일 적용\n  const jsx = serializeNodeWithVariantStyles(component.root, variants)\n  \n  return `\nexport function ${component.name}({ ${params} }) {\n  ${styleMaps.join('\\n  ')}\n  \n  return (\n    ${jsx}\n  )\n}\n  `\n}\n```",
				"testStrategy": "**테스트 전략:**\n1. 스냅샷 테스트:\n   - 다양한 variant 조합의 컴포넌트 → 생성된 코드가 예상과 일치\n2. 런타임 테스트:\n   - 생성된 코드를 실제로 실행하여 동작 확인\n   - props 변경 시 스타일 변경 확인\n3. 엣지 케이스:\n   - Variant 없는 컴포넌트\n   - 단일 property만 있는 경우\n   - 중첩 조합 (size + state)",
				"priority": "medium",
				"dependencies": ["6"],
				"status": "deferred",
				"subtasks": [],
				"updatedAt": "2026-01-30T12:23:52.249Z"
			},
			{
				"id": "8",
				"title": "Slot 패턴 데이터 모델 및 UI 구현",
				"description": "컴포넌트 내부에 교체 가능한 슬롯을 정의하고, 인스턴스에서 슬롯별 콘텐츠를 삽입할 수 있도록 구현합니다.",
				"details": "**Slot 시스템 설계:**\n- 컴포넌트 정의 시 특정 노드를 \"슬롯\"으로 마킹\n- 인스턴스에서 해당 슬롯에 다른 노드 트리 삽입\n- 필수/선택 슬롯 구분\n\n**타입 정의:**\n```typescript\n// variant.ts에 추가\nexport interface SlotDefinition {\n  id: string // 슬롯 고유 ID\n  name: string // 'header', 'body', 'footer'\n  nodeId: string // component.root 내에서 슬롯 역할을 하는 노드 ID\n  required: boolean\n  defaultContent?: NodeData // 기본 콘텐츠\n}\n\nexport interface ComponentDefinition {\n  // ...\n  slots?: SlotDefinition[]\n}\n\nexport interface InstanceNode {\n  // ...\n  slotContents?: {\n    [slotId: string]: NodeData[] // 해당 슬롯에 삽입할 노드들\n  }\n}\n```\n\n**UI 구현:**\n1. `packages/editor-shell/src/components/SlotEditor.tsx`\n2. 컴포넌트 편집 모드에서:\n   - 노드 우클릭 → \"Mark as Slot\" 메뉴\n   - 슬롯 이름, 필수 여부 입력\n3. 인스턴스 편집 모드에서:\n   - 슬롯 목록 표시\n   - 각 슬롯 클릭 → 하위 노드 편집 가능\n   - 드래그앤드롭으로 노드 삽입\n\n**렌더링 로직:**\n```typescript\nfunction renderNodeWithSlots(\n  node: NodeData,\n  slots: SlotDefinition[],\n  slotContents: Record<string, NodeData[]>\n): ReactNode {\n  const slot = slots.find(s => s.nodeId === node.id)\n  \n  if (slot) {\n    // 이 노드는 슬롯이므로 slotContents로 교체\n    const content = slotContents[slot.id] ?? slot.defaultContent ?? []\n    return content.map(child => renderNode(child))\n  }\n  \n  // 일반 노드\n  return renderNode(node)\n}\n```",
				"testStrategy": "**테스트 전략:**\n1. 유닛 테스트:\n   - 슬롯 정의 추가/삭제\n   - 슬롯 콘텐츠 교체 로직\n2. 통합 테스트:\n   - Card 컴포넌트 생성 → header/body/footer 슬롯 정의\n   - 인스턴스에서 각 슬롯에 다른 콘텐츠 삽입\n3. E2E 테스트:\n   - 슬롯 마킹 → 인스턴스 생성 → 슬롯 편집 UI 확인",
				"priority": "medium",
				"dependencies": ["7"],
				"status": "deferred",
				"subtasks": [],
				"updatedAt": "2026-01-30T12:23:53.858Z"
			},
			{
				"id": "9",
				"title": "Slot codegen 구현",
				"description": "Slot이 있는 컴포넌트를 children props 또는 named props로 export하며, 인스턴스는 해당 슬롯에 JSX를 전달하는 코드로 변환합니다.",
				"details": "**출력 형태 (Named Props 방식):**\n```tsx\n// 컴포넌트 정의\nexport function Card({ header, body, footer }) {\n  return (\n    <div className=\"card\">\n      <div className=\"card-header\">{header}</div>\n      <div className=\"card-body\">{body}</div>\n      <div className=\"card-footer\">{footer}</div>\n    </div>\n  )\n}\n\n// 인스턴스 사용\n<Card\n  header={<h2>Title</h2>}\n  body={<p>Content here</p>}\n  footer={<button>Action</button>}\n/>\n```\n\n**출력 형태 (Children 방식 - Compound 패턴 사전 단계):**\n```tsx\nexport function Card({ children }) {\n  return <div className=\"card\">{children}</div>\n}\n\n<Card>\n  <Card.Header><h2>Title</h2></Card.Header>\n  <Card.Body><p>Content</p></Card.Body>\n</Card>\n```\n\n**구현 방법:**\n1. `packages/editor-core/src/codegen/serialize-slot.ts` 생성\n2. 슬롯을 props로 변환:\n   - 각 SlotDefinition → 함수 파라미터\n   - 슬롯 노드 위치에 `{slotName}` 삽입\n3. 인스턴스 serialize 시:\n   - slotContents → JSX props\n\n**의사 코드:**\n```typescript\nfunction serializeComponentWithSlots(component: ComponentDefinition): string {\n  const { slots } = component\n  if (!slots || slots.length === 0) {\n    return serializeComponent(component)\n  }\n  \n  // 1. 파라미터 생성\n  const params = slots.map(s => s.name).join(', ')\n  \n  // 2. JSX에서 슬롯 위치에 {slotName} 삽입\n  const jsx = serializeNodeWithSlots(component.root, slots)\n  \n  return `\nexport function ${component.name}({ ${params} }) {\n  return (\n    ${jsx}\n  )\n}\n  `\n}\n\nfunction serializeNodeWithSlots(node: NodeData, slots: SlotDefinition[]): string {\n  const slot = slots.find(s => s.nodeId === node.id)\n  if (slot) {\n    return `{${slot.name}}`\n  }\n  // 일반 serialize\n  return serializeNode(node)\n}\n\nfunction serializeInstanceWithSlots(instance: InstanceNode, component: ComponentDefinition): string {\n  const { slots = [] } = component\n  const { slotContents = {} } = instance\n  \n  const slotProps = slots.map(slot => {\n    const content = slotContents[slot.id] ?? []\n    const jsx = content.map(serializeNode).join('\\n')\n    return `${slot.name}={${jsx ? `<>${jsx}</>` : 'null'}}`\n  }).join('\\n  ')\n  \n  return `<${component.name}\\n  ${slotProps}\\n/>`\n}\n```",
				"testStrategy": "**테스트 전략:**\n1. 스냅샷 테스트:\n   - Card 컴포넌트 (3개 슬롯) → 생성 코드 확인\n   - 인스턴스 → props 전달 코드 확인\n2. 런타임 테스트:\n   - 생성된 컴포넌트 실행 → 슬롯 내용 올바르게 렌더링\n3. 엣지 케이스:\n   - 빈 슬롯 (defaultContent 사용)\n   - 필수 슬롯 누락 (에러 또는 경고)",
				"priority": "medium",
				"dependencies": ["8"],
				"status": "deferred",
				"subtasks": [],
				"updatedAt": "2026-01-30T12:23:55.402Z"
			},
			{
				"id": "10",
				"title": "Export 고도화: Tailwind 및 CSS Module 지원",
				"description": "코드 export 시 Inline Style 외에 Tailwind CSS 클래스 또는 CSS Module로 변환하는 옵션을 제공합니다.",
				"details": "**지원 포맷:**\n1. Inline Style (기본, 이미 구현됨)\n2. Tailwind CSS 클래스\n3. CSS Module (.module.css 파일 생성)\n\n**구현 방법:**\n1. `packages/editor-core/src/codegen/style-converter.ts` 생성\n2. CSSProperties → Tailwind 클래스 매핑\n   - 라이브러리 사용: `css-to-tailwind` 또는 직접 매핑 테이블 작성\n   - 예: `{ fontSize: 14, fontWeight: 'bold' }` → `\"text-sm font-bold\"`\n3. CSSProperties → CSS Module\n   - 각 컴포넌트마다 `.module.css` 생성\n   - 고유 클래스명 생성: `${componentName}-${nodeId}`\n\n**Tailwind 변환 의사 코드:**\n```typescript\nfunction convertStyleToTailwind(style: CSSProperties): string {\n  const classes: string[] = []\n  \n  // 간단한 매핑 예시\n  if (style.display === 'flex') classes.push('flex')\n  if (style.flexDirection === 'column') classes.push('flex-col')\n  if (style.fontSize === 14) classes.push('text-sm')\n  if (style.fontWeight === 'bold') classes.push('font-bold')\n  // ... 더 많은 매핑\n  \n  return classes.join(' ')\n}\n\nfunction serializeNodeWithTailwind(node: NodeData): string {\n  const { type, style, children } = node\n  const className = style ? convertStyleToTailwind(style) : ''\n  \n  return `<${type} className=\"${className}\">${children}</${type}>`\n}\n```\n\n**CSS Module 변환 의사 코드:**\n```typescript\nfunction serializeToCSS Module(component: ComponentDefinition): { jsx: string; css: string } {\n  const cssRules: string[] = []\n  \n  function traverse(node: NodeData) {\n    if (node.style) {\n      const className = `${component.name}-${node.id}`\n      const cssRule = `.${className} {\\n${convertStyleToCSS(node.style)}\\n}`\n      cssRules.push(cssRule)\n      \n      // JSX에서 className 사용\n      return { ...node, props: { ...node.props, className } }\n    }\n    return node\n  }\n  \n  const transformedRoot = traverseAndTransform(component.root, traverse)\n  const jsx = serializeNode(transformedRoot)\n  const css = cssRules.join('\\n\\n')\n  \n  return { jsx, css }\n}\n```\n\n**Export UI:**\n- Export 버튼 → 모달 표시\n- 포맷 선택: Inline / Tailwind / CSS Module\n- TypeScript 옵션\n- 다운로드 버튼",
				"testStrategy": "**테스트 전략:**\n1. 유닛 테스트:\n   - `convertStyleToTailwind`: 다양한 스타일 → Tailwind 클래스\n   - `convertStyleToCSS`: CSSProperties → CSS 문자열\n2. 스냅샷 테스트:\n   - 동일한 컴포넌트를 세 가지 포맷으로 export → 각각 올바른 출력\n3. 통합 테스트:\n   - Tailwind 출력 → Tailwind 프로젝트에서 렌더링 확인\n   - CSS Module 출력 → Next.js/Vite에서 import 및 렌더링 확인",
				"priority": "low",
				"dependencies": ["9"],
				"status": "deferred",
				"subtasks": [],
				"updatedAt": "2026-01-30T12:23:56.931Z"
			},
			{
				"id": "11",
				"title": "Frame 도구로 노드 생성 기능 구현",
				"description": "툴바의 Frame 도구 버튼을 활성화하여 Canvas에서 마우스 드래그로 새로운 ElementNode(div)를 생성하는 기능을 구현합니다. 드래그 시작/종료 좌표로 크기를 계산하고, 생성 후 자동으로 select 도구로 전환됩니다.",
				"details": "**현재 상태 분석:**\n- 툴바에 Frame 도구 버튼 존재 (`packages/editor-shell/src/components/Toolbar.tsx:12`)\n- `EditorTool` 타입에 \"frame\" 정의됨 (`editor-core/src/types/editor.ts:6`)\n- Frame 도구 단축키 'f' 설정됨 (`keybindings/defaults.ts:21`)\n- `command:tool:frame` 등록됨 (`commands/tool.ts:12-13`)\n- SelectTool 구현 참고 가능 (`tools/SelectTool.ts`)\n- Canvas App에 드래그 핸들링 인프라 존재 (`editor-canvas/src/App.tsx`)\n\n**구현 단계:**\n\n**1. FrameTool 클래스 생성 (`packages/editor-shell/src/tools/FrameTool.ts`)**\n```typescript\nimport type { CanvasPointerEvent } from \"../events\"\nimport { useEditorStore } from \"../store/editor\"\nimport { BaseTool } from \"./types\"\nimport type { ElementNode } from \"@design-editor/core\"\n\n/**\n * Frame 도구 - 드래그로 div 노드 생성\n */\nexport class FrameTool extends BaseTool {\n  override name = \"frame\"\n  override cursor = \"crosshair\"\n\n  private dragStart: { x: number; y: number } | null = null\n  private tempNodeId: string | null = null\n\n  override onActivate(): void {\n    console.log(\"[FrameTool] 활성화\")\n  }\n\n  override onDeactivate(): void {\n    console.log(\"[FrameTool] 비활성화\")\n    this.dragStart = null\n    this.tempNodeId = null\n  }\n\n  override onPointerDown(e: CanvasPointerEvent): void {\n    // 빈 공간 클릭 시에만 드래그 시작\n    if (!e.targetNodeId) {\n      this.dragStart = { x: e.x, y: e.y }\n      console.log(\"[FrameTool] 드래그 시작:\", this.dragStart)\n    }\n  }\n\n  override onPointerMove(e: CanvasPointerEvent): void {\n    if (!this.dragStart) return\n\n    // 드래그 중 미리보기 (선택 사항)\n    // 여기서는 단순히 로깅만 수행\n    const width = Math.abs(e.x - this.dragStart.x)\n    const height = Math.abs(e.y - this.dragStart.y)\n    console.log(\"[FrameTool] 드래그 중:\", { width, height })\n  }\n\n  override onPointerUp(e: CanvasPointerEvent): void {\n    if (!this.dragStart) return\n\n    // 드래그 종료 - 노드 생성\n    const startX = Math.min(this.dragStart.x, e.x)\n    const startY = Math.min(this.dragStart.y, e.y)\n    const width = Math.abs(e.x - this.dragStart.x)\n    const height = Math.abs(e.y - this.dragStart.y)\n\n    // 최소 크기 체크 (너무 작은 드래그는 무시)\n    if (width < 10 || height < 10) {\n      console.log(\"[FrameTool] 드래그 크기가 너무 작음, 노드 생성 취소\")\n      this.dragStart = null\n      return\n    }\n\n    // 새 ElementNode 생성\n    const nodeId = `div-${Date.now()}-${Math.random().toString(36).slice(2, 7)}`\n    const newNode: ElementNode = {\n      id: nodeId,\n      type: \"element\",\n      tag: \"div\",\n      style: {\n        position: \"absolute\",\n        left: startX,\n        top: startY,\n        width,\n        height,\n        backgroundColor: \"#e0e0e0\",\n        border: \"1px solid #999\",\n      },\n      children: [],\n    }\n\n    // Store에 노드 추가 (현재 페이지의 루트에 추가)\n    const store = useEditorStore.getState()\n    const currentPage = store.document.children.find(p => p.id === store.currentPageId)\n    if (currentPage) {\n      store.addNode(currentPage.id, newNode)\n      store.setSelection([nodeId])\n      console.log(\"[FrameTool] 노드 생성 완료:\", nodeId)\n    }\n\n    // select 도구로 자동 전환\n    store.setActiveTool(\"select\")\n\n    // 상태 초기화\n    this.dragStart = null\n  }\n}\n```\n\n**2. FrameTool 등록 (`packages/editor-shell/src/App.tsx:31`)**\n```typescript\n// 기존:\ntoolRegistry.register(\"select\", new SelectTool())\n// TODO: 다른 Tool들도 등록 (frame, text, shape)\n\n// 수정 후:\nimport { FrameTool, SelectTool, toolRegistry } from \"./tools\"\n\ntoolRegistry.register(\"select\", new SelectTool())\ntoolRegistry.register(\"frame\", new FrameTool())\n```\n\n**3. FrameTool export 추가 (`packages/editor-shell/src/tools/index.ts`)**\n```typescript\nexport { SelectTool } from \"./SelectTool\"\nexport { FrameTool } from \"./FrameTool\"  // 추가\nexport { toolRegistry } from \"./ToolRegistry\"\n```\n\n**4. Canvas 드래그 핸들링 조건 수정 (`packages/editor-canvas/src/App.tsx`)**\n\n현재 Canvas는 `activeTool === \"select\"` 일 때만 로컬 드래그 상태를 추적합니다 (138번째 줄).\nFrame 도구는 Shell의 FrameTool 클래스에서 처리하므로 Canvas 측 수정은 불필요하지만,\n다른 도구들도 포인터 이벤트를 받을 수 있도록 조건 확인:\n\n```typescript\n// App.tsx:138 - 현재 코드\nif (targetNodeId && activeTool === \"select\") {\n  setLocalDragState({ ... })\n}\n\n// Frame 도구는 Shell에서 처리하므로 Canvas 수정 불필요\n// 이벤트는 모두 Shell로 전달되고, FrameTool이 처리함\n```\n\n**5. 키바인딩 동작 확인**\n- 'f' 키 → `command:tool:frame` → `toolRegistry.setActiveTool(\"frame\")`\n- 이미 설정되어 있으므로 추가 작업 불필요\n\n**아키텍처 노트:**\n- **Shell/Canvas 분리**: Canvas는 렌더링과 이벤트 전달만 담당, 실제 도구 로직은 Shell의 Tool 클래스에서 처리\n- **이벤트 흐름**: Canvas mousedown/move/up → Shell `onCanvasPointerEvent` → EventBus → FrameTool 메서드\n- **히스토리**: 노드 생성은 `addNode` 호출 시 Zustand temporal에 의해 자동 히스토리 기록\n- **좌표계**: Canvas의 클라이언트 좌표를 그대로 사용 (zoom 변환은 CSS transform으로 처리)\n\n**참고 파일:**\n- SelectTool 구현 패턴: `packages/editor-shell/src/tools/SelectTool.ts`\n- Tool 인터페이스: `packages/editor-shell/src/tools/types.ts`\n- Store addNode 메서드: `packages/editor-shell/src/store/editor.ts:211-246`\n- 이벤트 라우팅: `packages/editor-shell/src/events/EventRouter.ts`",
				"testStrategy": "**테스트 전략:**\n\n**1. 단위 테스트 (`vitest/tools/FrameTool.test.ts`)**\n```typescript\ndescribe(\"FrameTool\", () => {\n  it(\"드래그 시작 시 좌표 저장\", () => {\n    const tool = new FrameTool()\n    tool.onPointerDown({ x: 100, y: 100, targetNodeId: null, ... })\n    // dragStart 상태 확인\n  })\n\n  it(\"최소 크기 미만 드래그 시 노드 생성 안 함\", () => {\n    const tool = new FrameTool()\n    const initialNodeCount = useEditorStore.getState().document.children[0].children.length\n    tool.onPointerDown({ x: 100, y: 100, targetNodeId: null, ... })\n    tool.onPointerUp({ x: 105, y: 105, targetNodeId: null, ... })\n    const finalNodeCount = useEditorStore.getState().document.children[0].children.length\n    expect(finalNodeCount).toBe(initialNodeCount)\n  })\n\n  it(\"유효한 드래그 시 ElementNode 생성\", () => {\n    const tool = new FrameTool()\n    tool.onPointerDown({ x: 100, y: 100, targetNodeId: null, ... })\n    tool.onPointerUp({ x: 300, y: 200, targetNodeId: null, ... })\n    \n    const nodes = useEditorStore.getState().document.children[0].children\n    const newNode = nodes[nodes.length - 1] as ElementNode\n    expect(newNode.type).toBe(\"element\")\n    expect(newNode.tag).toBe(\"div\")\n    expect(newNode.style?.width).toBe(200)\n    expect(newNode.style?.height).toBe(100)\n  })\n\n  it(\"노드 생성 후 select 도구로 자동 전환\", () => {\n    const tool = new FrameTool()\n    useEditorStore.getState().setActiveTool(\"frame\")\n    tool.onPointerDown({ x: 100, y: 100, targetNodeId: null, ... })\n    tool.onPointerUp({ x: 300, y: 200, targetNodeId: null, ... })\n    expect(useEditorStore.getState().activeTool).toBe(\"select\")\n  })\n\n  it(\"노드 생성 후 새 노드가 자동 선택됨\", () => {\n    const tool = new FrameTool()\n    tool.onPointerDown({ x: 100, y: 100, targetNodeId: null, ... })\n    tool.onPointerUp({ x: 300, y: 200, targetNodeId: null, ... })\n    \n    const selection = useEditorStore.getState().selection\n    expect(selection.length).toBe(1)\n    expect(selection[0]).toMatch(/^div-/)\n  })\n})\n```\n\n**2. 통합 테스트 (dev 환경에서 수동 테스트)**\n1. 개발 서버 실행: `cd packages/editor-shell && pnpm dev`, `cd packages/editor-canvas && pnpm dev`\n2. 툴바에서 Frame 도구 클릭 (⬜ 아이콘)\n3. activeTool이 \"frame\"으로 변경 확인 (버튼 active 스타일)\n4. Canvas 빈 공간에서 마우스 드래그\n5. 드래그한 영역에 회색 div 노드 생성 확인\n6. 생성된 노드가 자동 선택됨 확인 (파란 테두리)\n7. activeTool이 \"select\"로 자동 전환 확인\n8. Layers 패널에 새 노드 표시 확인\n9. Properties 패널에서 width/height 확인\n\n**3. E2E 테스트 (`e2e/tests/frame-tool.spec.ts`)**\n```typescript\nimport { expect, test } from \"@playwright/test\"\n\ntest(\"Frame 도구로 노드 생성\", async ({ page }) => {\n  await page.goto(\"http://localhost:3000\")\n  \n  // Frame 도구 선택\n  await page.click('[title=\"Frame\"]')\n  await expect(page.locator('[title=\"Frame\"].active')).toBeVisible()\n  \n  // Canvas iframe 접근\n  const canvasFrame = page.frameLocator(\"iframe.canvas-iframe\")\n  await expect(canvasFrame.locator(\".canvas-app\")).toBeVisible()\n  \n  // 드래그로 노드 생성\n  const canvas = canvasFrame.locator(\".canvas-app\")\n  await canvas.hover({ position: { x: 100, y: 100 } })\n  await page.mouse.down()\n  await canvas.hover({ position: { x: 300, y: 200 } })\n  await page.mouse.up()\n  \n  // 새 노드 생성 확인\n  await expect(canvasFrame.locator(\".node-wrapper\").last()).toBeVisible()\n  \n  // select 도구로 자동 전환 확인\n  await expect(page.locator('[title=\"Select\"].active')).toBeVisible()\n  \n  // Layers 패널에서 새 노드 확인\n  await expect(page.locator('.layer-item').last()).toContainText('div')\n})\n\ntest(\"최소 크기 미만 드래그 시 노드 생성 안 함\", async ({ page }) => {\n  await page.goto(\"http://localhost:3000\")\n  await page.click('[title=\"Frame\"]')\n  \n  const canvasFrame = page.frameLocator(\"iframe.canvas-iframe\")\n  const initialCount = await canvasFrame.locator(\".node-wrapper\").count()\n  \n  // 5px 드래그 (최소 크기 미만)\n  const canvas = canvasFrame.locator(\".canvas-app\")\n  await canvas.hover({ position: { x: 100, y: 100 } })\n  await page.mouse.down()\n  await canvas.hover({ position: { x: 105, y: 105 } })\n  await page.mouse.up()\n  \n  const finalCount = await canvasFrame.locator(\".node-wrapper\").count()\n  expect(finalCount).toBe(initialCount)\n})\n```\n\n**4. 키바인딩 테스트**\n1. Canvas에 포커스\n2. 'f' 키 입력\n3. Frame 도구 활성화 확인\n4. 드래그로 노드 생성\n5. 'v' 키 입력 (select 도구 단축키)\n6. select 도구 활성화 확인\n\n**5. 히스토리 테스트**\n1. Frame 도구로 노드 생성\n2. Cmd+Z (Undo) → 노드 삭제 확인\n3. Cmd+Shift+Z (Redo) → 노드 복원 확인\n\n**6. 엣지 케이스 테스트**\n- 기존 노드 위에서 드래그 시작 → 노드 생성 안 함\n- 드래그 방향 (왼→오, 오→왼, 위→아래, 아래→위) → 모두 정상 동작\n- zoom 상태에서 노드 생성 → 좌표 정확성 확인\n- 여러 페이지 전환 후 노드 생성 → 현재 페이지에 생성 확인",
				"status": "done",
				"dependencies": [],
				"priority": "high",
				"subtasks": [],
				"updatedAt": "2026-01-31T07:16:50.226Z"
			},
			{
				"id": "12",
				"title": "Shape 도구로 도형 노드 생성 기능 구현",
				"description": "툴바의 Shape 도구를 활성화하여 Canvas에서 마우스 드래그로 Rectangle 또는 Ellipse 도형 노드를 생성합니다. 서브메뉴를 통해 도형 타입을 선택하고, 드래그로 크기를 지정하며, 생성 후 자동으로 select 도구로 전환됩니다.",
				"details": "**현재 상태 분석:**\n- 툴바에 Shape 도구 버튼 존재 (`packages/editor-shell/src/components/Toolbar.tsx:14`)\n- `EditorTool` 타입에 \"shape\" 정의됨 (`editor-core/src/types/editor.ts:6`)\n- Shape 도구 단축키 'r' 설정됨 (`keybindings/defaults.ts:23`)\n- `command:tool:shape` 등록됨 (`commands/tool.ts:20-22`)\n- Frame 도구 구현(Task 11) 참고 가능\n- Canvas App에 드래그 핸들링 인프라 존재 (`editor-canvas/src/App.tsx`)\n\n**구현 단계:**\n\n**1. Shape 서브 타입 타입 정의 추가**\n\n`packages/editor-core/src/types/editor.ts`에 Shape 타입 추가:\n```typescript\n/**\n * Shape 도구 서브 타입\n */\nexport type ShapeType = \"rectangle\" | \"ellipse\"\n\nexport interface EditorState {\n  // ... 기존 필드들\n  activeShapeType: ShapeType // 현재 선택된 도형 타입 추가\n}\n```\n\n**2. EditorStore에 Shape 상태 및 액션 추가**\n\n`packages/editor-shell/src/store/editor.ts`:\n```typescript\nexport interface EditorState {\n  // ...\n  activeShapeType: ShapeType\n}\n\n// 초기 상태\nconst initialState: EditorState = {\n  // ...\n  activeShapeType: \"rectangle\" as ShapeType,\n}\n\n// 액션 추가\nexport interface EditorActions {\n  // ...\n  setActiveShapeType: (shapeType: ShapeType) => void\n}\n\n// 구현\nsetActiveShapeType: (shapeType) => {\n  set({ activeShapeType: shapeType })\n}\n```\n\n**3. ShapeTool 클래스 생성**\n\n`packages/editor-shell/src/tools/ShapeTool.ts`:\n```typescript\nimport type { CanvasPointerEvent } from \"../events\"\nimport { useEditorStore } from \"../store/editor\"\nimport { BaseTool } from \"./types\"\nimport { nanoid } from \"nanoid\"\nimport type { ElementNode } from \"@design-editor/core\"\n\n/**\n * Shape 도구 - 드래그로 Rectangle/Ellipse 생성\n */\nexport class ShapeTool extends BaseTool {\n  override name = \"shape\"\n  override cursor = \"crosshair\"\n  \n  private dragStart: { x: number; y: number } | null = null\n  private previewNodeId: string | null = null\n\n  override onActivate(): void {\n    console.log(\"ShapeTool activated\")\n  }\n\n  override onDeactivate(): void {\n    // 미완성 preview 노드 제거\n    if (this.previewNodeId) {\n      useEditorStore.getState().removeNode(this.previewNodeId)\n      this.previewNodeId = null\n    }\n    this.dragStart = null\n  }\n\n  override onPointerDown(e: CanvasPointerEvent): void {\n    // 빈 공간에서만 드래그 시작 (노드 위에서는 무시)\n    if (e.targetNodeId) return\n\n    this.dragStart = { x: e.x, y: e.y }\n    \n    // 히스토리 일시정지 (드래그 중 매 프레임마다 기록 방지)\n    useEditorStore.temporal.getState().pause()\n  }\n\n  override onPointerMove(e: CanvasPointerEvent): void {\n    if (!this.dragStart) return\n\n    const width = Math.abs(e.x - this.dragStart.x)\n    const height = Math.abs(e.y - this.dragStart.y)\n    const left = Math.min(e.x, this.dragStart.x)\n    const top = Math.min(e.y, this.dragStart.y)\n\n    const { activeShapeType, document, currentPageId } = useEditorStore.getState()\n\n    // Rectangle: borderRadius 없음 또는 작은 값\n    // Ellipse: borderRadius 50%로 원형 구현\n    const shapeStyle = activeShapeType === \"ellipse\" \n      ? { borderRadius: \"50%\" }\n      : {}\n\n    if (this.previewNodeId) {\n      // 기존 preview 노드 업데이트\n      useEditorStore.getState().updateNode(this.previewNodeId, {\n        style: {\n          position: \"absolute\",\n          left,\n          top,\n          width,\n          height,\n          backgroundColor: \"#E0E0E0\",\n          border: \"1px solid #999\",\n          ...shapeStyle,\n        },\n      })\n    } else {\n      // 새 preview 노드 생성\n      this.previewNodeId = nanoid()\n      const newNode: ElementNode = {\n        id: this.previewNodeId,\n        type: \"element\",\n        tag: \"div\",\n        style: {\n          position: \"absolute\",\n          left,\n          top,\n          width,\n          height,\n          backgroundColor: \"#E0E0E0\",\n          border: \"1px solid #999\",\n          ...shapeStyle,\n        },\n      }\n      useEditorStore.getState().addNode(currentPageId, newNode)\n    }\n  }\n\n  override onPointerUp(e: CanvasPointerEvent): void {\n    if (!this.dragStart || !this.previewNodeId) {\n      // 드래그 없이 클릭만 한 경우\n      this.dragStart = null\n      useEditorStore.temporal.getState().resume()\n      return\n    }\n\n    const width = Math.abs(e.x - this.dragStart.x)\n    const height = Math.abs(e.y - this.dragStart.y)\n\n    // 최소 크기 체크 (10x10 미만이면 생성 안 함)\n    if (width < 10 || height < 10) {\n      useEditorStore.getState().removeNode(this.previewNodeId)\n      this.previewNodeId = null\n      this.dragStart = null\n      useEditorStore.temporal.getState().resume()\n      return\n    }\n\n    const left = Math.min(e.x, this.dragStart.x)\n    const top = Math.min(e.y, this.dragStart.y)\n    const { activeShapeType } = useEditorStore.getState()\n\n    // 최종 스타일 확정\n    const shapeStyle = activeShapeType === \"ellipse\"\n      ? { borderRadius: \"50%\" }\n      : { borderRadius: \"0px\" }\n\n    useEditorStore.getState().updateNode(this.previewNodeId, {\n      style: {\n        position: \"absolute\",\n        left,\n        top,\n        width,\n        height,\n        backgroundColor: \"#CCCCCC\",\n        border: \"1px solid #666\",\n        ...shapeStyle,\n      },\n    })\n\n    // 생성된 노드 선택\n    useEditorStore.getState().setSelection([this.previewNodeId])\n\n    // 드래그 완료 → 히스토리 재개\n    useEditorStore.temporal.getState().resume()\n\n    // 상태 초기화\n    this.previewNodeId = null\n    this.dragStart = null\n\n    // select 도구로 자동 전환\n    useEditorStore.getState().setActiveTool(\"select\")\n  }\n}\n```\n\n**4. ShapeTool 등록**\n\n`packages/editor-shell/src/tools/index.ts`:\n```typescript\nexport { SelectTool } from \"./SelectTool\"\nexport { ShapeTool } from \"./ShapeTool\"\nexport { toolRegistry } from \"./ToolRegistry\"\nexport { BaseTool, type DragEndEvent, type Tool } from \"./types\"\n```\n\n앱 초기화 시 등록 (`packages/editor-shell/src/App.tsx` 또는 초기화 코드):\n```typescript\nimport { SelectTool, ShapeTool, toolRegistry } from \"./tools\"\n\n// Tool 등록\ntoolRegistry.register(\"select\", new SelectTool())\ntoolRegistry.register(\"shape\", new ShapeTool())\n```\n\n**5. Toolbar에 Shape 서브메뉴 추가**\n\n`packages/editor-shell/src/components/Toolbar.tsx`:\n```typescript\nimport type { EditorTool, ShapeType } from \"@design-editor/core\"\n\nexport function Toolbar() {\n  const { activeTool, setActiveTool, activeShapeType, setActiveShapeType, ... } = useEditorStore(...)\n  \n  const [showShapeMenu, setShowShapeMenu] = useState(false)\n\n  const handleShapeToolClick = () => {\n    if (activeTool === \"shape\") {\n      // 이미 활성화된 경우 서브메뉴 토글\n      setShowShapeMenu(!showShapeMenu)\n    } else {\n      // 처음 활성화 시 서브메뉴 표시\n      setActiveTool(\"shape\")\n      setShowShapeMenu(true)\n    }\n  }\n\n  const handleShapeTypeSelect = (shapeType: ShapeType) => {\n    setActiveShapeType(shapeType)\n    setActiveTool(\"shape\")\n    setShowShapeMenu(false)\n  }\n\n  return (\n    <div className=\"toolbar\">\n      {/* ... 기존 버튼들 */}\n      \n      <div className=\"shape-tool-container\">\n        <button\n          className={`toolbar-button ${activeTool === \"shape\" ? \"active\" : \"\"}`}\n          onClick={handleShapeToolClick}\n          title=\"Shape\"\n        >\n          ○\n        </button>\n        {showShapeMenu && (\n          <div className=\"shape-menu\">\n            <button\n              className={`menu-item ${activeShapeType === \"rectangle\" ? \"active\" : \"\"}`}\n              onClick={() => handleShapeTypeSelect(\"rectangle\")}\n            >\n              ⬜ Rectangle\n            </button>\n            <button\n              className={`menu-item ${activeShapeType === \"ellipse\" ? \"active\" : \"\"}`}\n              onClick={() => handleShapeTypeSelect(\"ellipse\")}\n            >\n              ○ Ellipse\n            </button>\n          </div>\n        )}\n      </div>\n    </div>\n  )\n}\n```\n\n**6. CSS 스타일 추가**\n\n`packages/editor-shell/src/components/Toolbar.css`:\n```css\n.shape-tool-container {\n  position: relative;\n  display: inline-block;\n}\n\n.shape-menu {\n  position: absolute;\n  top: 100%;\n  left: 0;\n  margin-top: 4px;\n  background: white;\n  border: 1px solid #ddd;\n  border-radius: 4px;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);\n  z-index: 1000;\n  min-width: 120px;\n}\n\n.shape-menu .menu-item {\n  display: block;\n  width: 100%;\n  padding: 8px 12px;\n  text-align: left;\n  border: none;\n  background: none;\n  cursor: pointer;\n  font-size: 14px;\n}\n\n.shape-menu .menu-item:hover {\n  background: #f0f0f0;\n}\n\n.shape-menu .menu-item.active {\n  background: #e3f2fd;\n  color: #1976d2;\n}\n```\n\n**7. Canvas에서 Shape 도구 처리**\n\n`packages/editor-canvas/src/App.tsx`에서 이미 모든 activeTool에 대해 드래그를 처리하므로 추가 수정 불필요. 단, shape 도구 활성화 시 crosshair 커서 적용:\n\n```typescript\nconst handleCanvasMouseDown = useCallback(\n  (e: React.MouseEvent) => {\n    // shape 도구는 빈 공간에서만 드래그 시작\n    if (activeTool === \"shape\" && !getTargetNodeId(e.target)) {\n      // Shell에 전달하면 ShapeTool이 처리\n    }\n    // ... 기존 로직\n  },\n  [activeTool, ...]\n)\n\n// 커서 스타일\n<div\n  className=\"canvas-app\"\n  style={{ \n    transform: `scale(${zoom})`,\n    cursor: activeTool === \"shape\" ? \"crosshair\" : \"default\"\n  }}\n  ...\n>\n```\n\n**8. EventRouter에 Shape 이벤트 라우팅 추가**\n\n`packages/editor-shell/src/events/EventRouter.ts`에서 이미 모든 도구 이벤트를 `toolRegistry.getActiveTool()`로 라우팅하므로 추가 수정 불필요.\n\n**구현 우선순위:**\n1. 타입 정의 및 Store 상태 추가\n2. ShapeTool 클래스 구현\n3. Tool 등록\n4. Toolbar 서브메뉴 UI 구현\n5. CSS 스타일링\n6. Canvas 커서 처리\n\n**기술 세부사항:**\n- Rectangle: `borderRadius: \"0px\"` (또는 작은 값으로 둥근 모서리 가능)\n- Ellipse: `borderRadius: \"50%\"`로 원형 구현\n- 드래그 중 preview 노드를 실시간으로 업데이트하여 시각적 피드백 제공\n- 최소 크기(10x10px) 미만이면 노드 생성하지 않음\n- 생성 후 자동으로 select 도구로 전환하여 즉시 편집 가능",
				"testStrategy": "**테스트 전략:**\n\n**1. 단위 테스트 (`vitest/tools/ShapeTool.test.ts`)**\n```typescript\ndescribe(\"ShapeTool\", () => {\n  it(\"활성화 시 crosshair 커서 설정\", () => {\n    const tool = new ShapeTool()\n    expect(tool.cursor).toBe(\"crosshair\")\n  })\n\n  it(\"드래그 시작 시 좌표 저장 (빈 공간)\", () => {\n    const tool = new ShapeTool()\n    tool.onPointerDown({ x: 100, y: 100, targetNodeId: null, ... })\n    // dragStart 상태 확인\n  })\n\n  it(\"노드 위에서 드래그 시작 무시\", () => {\n    const tool = new ShapeTool()\n    tool.onPointerDown({ x: 100, y: 100, targetNodeId: \"node-1\", ... })\n    // dragStart null 확인\n  })\n\n  it(\"드래그 중 preview 노드 크기 업데이트\", () => {\n    const tool = new ShapeTool()\n    tool.onPointerDown({ x: 100, y: 100, targetNodeId: null, ... })\n    tool.onPointerMove({ x: 200, y: 150, ... })\n    // 스토어에 노드 추가 및 크기 확인\n  })\n\n  it(\"최소 크기 미만 드래그 시 노드 생성 안 함\", () => {\n    const tool = new ShapeTool()\n    tool.onPointerDown({ x: 100, y: 100, targetNodeId: null, ... })\n    tool.onPointerUp({ x: 105, y: 105, ... })\n    // 노드 생성되지 않았는지 확인\n  })\n\n  it(\"Rectangle 생성 시 borderRadius 0\", () => {\n    useEditorStore.getState().setActiveShapeType(\"rectangle\")\n    const tool = new ShapeTool()\n    tool.onPointerDown({ x: 100, y: 100, targetNodeId: null, ... })\n    tool.onPointerUp({ x: 200, y: 200, ... })\n    const node = useEditorStore.getState().findNode(...)\n    expect(node.style.borderRadius).toBe(\"0px\")\n  })\n\n  it(\"Ellipse 생성 시 borderRadius 50%\", () => {\n    useEditorStore.getState().setActiveShapeType(\"ellipse\")\n    const tool = new ShapeTool()\n    tool.onPointerDown({ x: 100, y: 100, targetNodeId: null, ... })\n    tool.onPointerUp({ x: 200, y: 200, ... })\n    const node = useEditorStore.getState().findNode(...)\n    expect(node.style.borderRadius).toBe(\"50%\")\n  })\n\n  it(\"생성 후 노드 선택됨\", () => {\n    const tool = new ShapeTool()\n    tool.onPointerDown({ x: 100, y: 100, targetNodeId: null, ... })\n    tool.onPointerUp({ x: 200, y: 200, ... })\n    const selection = useEditorStore.getState().selection\n    expect(selection.length).toBe(1)\n  })\n\n  it(\"생성 후 select 도구로 전환\", () => {\n    const tool = new ShapeTool()\n    tool.onPointerDown({ x: 100, y: 100, targetNodeId: null, ... })\n    tool.onPointerUp({ x: 200, y: 200, ... })\n    expect(useEditorStore.getState().activeTool).toBe(\"select\")\n  })\n\n  it(\"비활성화 시 미완성 preview 노드 제거\", () => {\n    const tool = new ShapeTool()\n    tool.onPointerDown({ x: 100, y: 100, targetNodeId: null, ... })\n    tool.onPointerMove({ x: 150, y: 150, ... })\n    tool.onDeactivate()\n    // preview 노드가 제거되었는지 확인\n  })\n})\n```\n\n**2. 통합 테스트**\n- Toolbar에서 Shape 버튼 클릭 → 서브메뉴 표시 확인\n- Rectangle 선택 → activeShapeType 상태 변경 확인\n- Ellipse 선택 → activeShapeType 상태 변경 확인\n- Canvas에서 드래그 → Rectangle 생성 → borderRadius 확인\n- Canvas에서 드래그 → Ellipse 생성 → borderRadius: 50% 확인\n- 생성 후 노드 선택 상태 확인\n- 생성 후 activeTool이 \"select\"로 변경되는지 확인\n\n**3. E2E 테스트 (Playwright)**\n```typescript\ntest(\"Shape 도구로 Rectangle 생성\", async ({ page }) => {\n  await page.goto(\"http://localhost:3000\")\n  \n  // Shape 도구 클릭\n  await page.click('[title=\"Shape\"]')\n  \n  // Rectangle 선택\n  await page.click('text=Rectangle')\n  \n  // Canvas에서 드래그\n  const canvas = page.locator(\".canvas-app\")\n  await canvas.hover({ position: { x: 100, y: 100 } })\n  await page.mouse.down()\n  await canvas.hover({ position: { x: 200, y: 150 } })\n  await page.mouse.up()\n  \n  // Rectangle 노드 생성 확인\n  const rect = page.locator('[data-node-id]').last()\n  await expect(rect).toBeVisible()\n  \n  // borderRadius 확인\n  const style = await rect.getAttribute(\"style\")\n  expect(style).toContain(\"border-radius: 0px\")\n  \n  // 선택 상태 확인\n  await expect(rect).toHaveClass(/selected/)\n  \n  // select 도구로 전환 확인\n  await expect(page.locator('[title=\"Select\"]')).toHaveClass(/active/)\n})\n\ntest(\"Shape 도구로 Ellipse 생성\", async ({ page }) => {\n  await page.goto(\"http://localhost:3000\")\n  \n  // Shape 도구 클릭 → Ellipse 선택\n  await page.click('[title=\"Shape\"]')\n  await page.click('text=Ellipse')\n  \n  // Canvas에서 드래그\n  const canvas = page.locator(\".canvas-app\")\n  await canvas.hover({ position: { x: 150, y: 150 } })\n  await page.mouse.down()\n  await canvas.hover({ position: { x: 250, y: 250 } })\n  await page.mouse.up()\n  \n  // Ellipse 노드 생성 확인\n  const ellipse = page.locator('[data-node-id]').last()\n  await expect(ellipse).toBeVisible()\n  \n  // borderRadius: 50% 확인\n  const style = await ellipse.getAttribute(\"style\")\n  expect(style).toContain(\"border-radius: 50%\")\n})\n\ntest(\"최소 크기 미만 드래그 시 노드 생성 안 함\", async ({ page }) => {\n  await page.goto(\"http://localhost:3000\")\n  \n  const initialNodeCount = await page.locator('[data-node-id]').count()\n  \n  await page.click('[title=\"Shape\"]')\n  await page.click('text=Rectangle')\n  \n  // 작은 드래그\n  const canvas = page.locator(\".canvas-app\")\n  await canvas.hover({ position: { x: 100, y: 100 } })\n  await page.mouse.down()\n  await canvas.hover({ position: { x: 105, y: 105 } })\n  await page.mouse.up()\n  \n  // 노드 수 변화 없음 확인\n  const finalNodeCount = await page.locator('[data-node-id]').count()\n  expect(finalNodeCount).toBe(initialNodeCount)\n})\n\ntest(\"단축키 'r'로 Shape 도구 활성화\", async ({ page }) => {\n  await page.goto(\"http://localhost:3000\")\n  \n  await page.keyboard.press(\"r\")\n  \n  // Shape 도구 활성화 확인\n  await expect(page.locator('[title=\"Shape\"]')).toHaveClass(/active/)\n})\n```\n\n**4. 시각적 회귀 테스트**\n- Rectangle 생성 → 스크린샷 비교\n- Ellipse 생성 → 스크린샷 비교\n- 드래그 중 preview → 스크린샷 비교\n\n**5. 수동 테스트 체크리스트**\n- [ ] Toolbar에서 Shape 버튼 클릭 시 서브메뉴 표시\n- [ ] Rectangle 선택 후 드래그 → 사각형 생성\n- [ ] Ellipse 선택 후 드래그 → 타원 생성\n- [ ] 작은 드래그(10px 미만) → 노드 생성 안 됨\n- [ ] 생성된 노드가 자동으로 선택됨\n- [ ] 생성 후 select 도구로 자동 전환\n- [ ] 단축키 'r'로 Shape 도구 활성화\n- [ ] Shape 도구 활성화 시 커서가 crosshair로 변경\n- [ ] 드래그 중 preview 노드가 실시간으로 크기 변경\n- [ ] 다른 도구로 전환 시 미완성 preview 제거",
				"status": "pending",
				"dependencies": ["11"],
				"priority": "high",
				"subtasks": []
			},
			{
				"id": "13",
				"title": "Text 도구로 텍스트 노드 생성 기능 구현",
				"description": "툴바의 Text 도구를 활성화하여 Canvas에서 클릭으로 텍스트 노드(p 또는 span)를 생성합니다. 클릭 위치에 기본 텍스트가 포함된 노드를 생성하고, 생성 후 자동으로 select 도구로 전환됩니다.",
				"details": "**현재 상태 분석:**\n- 툴바에 Text 도구 버튼 존재 (`packages/editor-shell/src/components/Toolbar.tsx:13`)\n- `EditorTool` 타입에 \"text\" 정의됨 (`editor-core/src/types/editor.ts:6`)\n- Text 도구 단축키 't' 설정됨 (`keybindings/defaults.ts:22`)\n- `command:tool:text` 등록됨 (`commands/tool.ts:16-18`)\n- SelectTool 구현 참고 가능 (`tools/SelectTool.ts`)\n- Canvas App에 클릭 핸들링 인프라 존재 (`editor-canvas/src/App.tsx`)\n- ID 생성 방식: `Date.now()` + `Math.random()` 조합 (`editor.ts:117`)\n\n**구현 단계:**\n\n**1. TextTool 클래스 생성 (`packages/editor-shell/src/tools/TextTool.ts`)**\n```typescript\nimport type { CanvasPointerEvent } from \"../events\"\nimport { useEditorStore } from \"../store/editor\"\nimport { BaseTool } from \"./types\"\n\n/**\n * 텍스트 도구 - 클릭으로 텍스트 노드 생성\n */\nexport class TextTool extends BaseTool {\n\toverride name = \"text\"\n\toverride cursor = \"text\" // 텍스트 커서 스타일\n\n\toverride onPointerDown(e: CanvasPointerEvent): void {\n\t\t// 빈 공간 클릭 시에만 텍스트 노드 생성\n\t\tif (e.targetNodeId) return\n\n\t\tconst store = useEditorStore.getState()\n\t\tconst page = store.document.children.find(p => p.id === store.currentPageId)\n\t\tif (!page) return\n\n\t\t// 텍스트 노드 생성 (기본값: p 태그)\n\t\tconst textNodeId = `text-${Date.now()}-${Math.random().toString(36).slice(2, 7)}`\n\t\tconst textNode: ElementNode = {\n\t\t\tid: textNodeId,\n\t\t\ttype: \"element\",\n\t\t\ttag: \"p\", // 기본 p 태그 (또는 span 선택 가능)\n\t\t\tstyle: {\n\t\t\t\tposition: \"absolute\",\n\t\t\t\tleft: e.x / store.zoom, // zoom 고려\n\t\t\t\ttop: e.y / store.zoom,\n\t\t\t\tfontSize: 16,\n\t\t\t\tcolor: \"#000000\",\n\t\t\t\tfontFamily: \"system-ui, sans-serif\",\n\t\t\t},\n\t\t\tchildren: \"Text\", // 기본 텍스트\n\t\t}\n\n\t\t// 페이지에 노드 추가\n\t\tstore.addNode(page.id, textNode)\n\t\t\n\t\t// 생성된 노드 선택\n\t\tstore.setSelection([textNodeId])\n\n\t\t// select 도구로 자동 전환\n\t\timport { toolRegistry } from \"./index\"\n\t\ttoolRegistry.setActiveTool(\"select\")\n\t}\n}\n```\n\n**2. TextTool 등록 (`packages/editor-shell/src/tools/index.ts`)**\n```typescript\nimport { SelectTool } from \"./SelectTool\"\nimport { TextTool } from \"./TextTool\"\nimport { toolRegistry } from \"./ToolRegistry\"\n\n// Tool 초기화\nexport function initializeTools() {\n\ttoolRegistry.register(\"select\", new SelectTool())\n\ttoolRegistry.register(\"text\", new TextTool())\n\t// frame, shape는 Task 11, 12에서 추가\n}\n\nexport { toolRegistry }\n```\n\n**3. Shell App에서 초기화 (`packages/editor-shell/src/App.tsx`)**\n```typescript\nimport { initializeTools } from \"./tools\"\n\n// App 컴포넌트 내부 useEffect\nuseEffect(() => {\n\tinitializeTools()\n}, [])\n```\n\n**4. EventRouter에 Tool 이벤트 연결 (이미 존재할 가능성 높음)**\n`packages/editor-shell/src/events/EventRouter.ts`에서 Canvas 이벤트를 Tool로 라우팅:\n```typescript\nimport { toolRegistry } from \"../tools\"\n\nexport class EventRouter {\n\trouteCanvasPointerEvent(e: CanvasPointerEvent) {\n\t\tconst tool = toolRegistry.getActiveTool()\n\t\tif (!tool) return\n\n\t\tswitch (e.type) {\n\t\t\tcase \"mousedown\":\n\t\t\t\ttool.onPointerDown(e)\n\t\t\t\tbreak\n\t\t\tcase \"mousemove\":\n\t\t\t\ttool.onPointerMove(e)\n\t\t\t\tbreak\n\t\t\tcase \"mouseup\":\n\t\t\t\ttool.onPointerUp(e)\n\t\t\t\tbreak\n\t\t\tcase \"dragend\":\n\t\t\t\ttool.onDragEnd(e)\n\t\t\t\tbreak\n\t\t}\n\t}\n}\n```\n\n**5. Canvas 커서 스타일 적용 (`packages/editor-canvas/src/App.tsx`)**\nactiveTool에 따라 Canvas 커서 변경:\n```tsx\n<div\n\tclassName=\"canvas-app\"\n\tstyle={{ \n\t\ttransform: `scale(${zoom})`,\n\t\tcursor: activeTool === \"text\" ? \"text\" : \"default\"\n\t}}\n\tonMouseDown={handleCanvasMouseDown}\n\t// ...\n>\n```\n\n**6. (Optional) 텍스트 편집 모드 진입**\n생성 직후 텍스트를 편집할 수 있도록 `contentEditable` 활성화:\n- `NodeWrapper.tsx`에서 텍스트 노드 감지 시 `contentEditable` 속성 추가\n- `onBlur` 이벤트로 편집 완료 시 store 업데이트\n- 이 기능은 Task 13의 범위를 벗어나므로 별도 Task로 분리 권장\n\n**주요 고려사항:**\n1. **Zoom 처리**: 클릭 좌표를 zoom으로 나누어 실제 Canvas 좌표로 변환\n2. **기본 스타일**: 가독성 있는 기본 폰트 크기(16px) 및 색상 설정\n3. **Tag 선택**: `p` (블록) vs `span` (인라인) 선택 가능 - 기본값 `p` 권장\n4. **자동 전환**: 생성 후 select 도구로 자동 전환하여 즉시 이동/편집 가능\n5. **빈 공간 클릭**: 기존 노드 클릭 시에는 생성하지 않음 (SelectTool과 충돌 방지)",
				"testStrategy": "**테스트 전략:**\n\n**1. 단위 테스트 (`vitest/tools/TextTool.test.ts`)**\n```typescript\ndescribe(\"TextTool\", () => {\n\tit(\"활성화 시 text 커서 설정\", () => {\n\t\tconst tool = new TextTool()\n\t\texpect(tool.cursor).toBe(\"text\")\n\t})\n\n\tit(\"빈 공간 클릭 시 텍스트 노드 생성\", () => {\n\t\tconst tool = new TextTool()\n\t\tconst initialNodeCount = useEditorStore.getState().document.children[0].children.length\n\t\t\n\t\ttool.onPointerDown({ \n\t\t\tx: 100, y: 100, \n\t\t\ttargetNodeId: null, \n\t\t\ttype: \"mousedown\",\n\t\t\tclientX: 100, clientY: 100,\n\t\t\tshiftKey: false, ctrlKey: false, metaKey: false, altKey: false\n\t\t})\n\t\t\n\t\tconst finalNodeCount = useEditorStore.getState().document.children[0].children.length\n\t\texpect(finalNodeCount).toBe(initialNodeCount + 1)\n\t})\n\n\tit(\"기존 노드 클릭 시 텍스트 노드 생성 안 함\", () => {\n\t\tconst tool = new TextTool()\n\t\tconst initialNodeCount = useEditorStore.getState().document.children[0].children.length\n\t\t\n\t\ttool.onPointerDown({ \n\t\t\tx: 100, y: 100, \n\t\t\ttargetNodeId: \"existing-node\", \n\t\t\t// ...\n\t\t})\n\t\t\n\t\tconst finalNodeCount = useEditorStore.getState().document.children[0].children.length\n\t\texpect(finalNodeCount).toBe(initialNodeCount) // 변화 없음\n\t})\n\n\tit(\"생성된 텍스트 노드가 올바른 속성을 가짐\", () => {\n\t\tconst tool = new TextTool()\n\t\ttool.onPointerDown({ x: 100, y: 200, targetNodeId: null, /* ... */ })\n\t\t\n\t\tconst nodes = useEditorStore.getState().document.children[0].children\n\t\tconst newNode = nodes[nodes.length - 1]\n\t\t\n\t\texpect(newNode.type).toBe(\"element\")\n\t\texpect(newNode.tag).toBe(\"p\")\n\t\texpect(newNode.children).toBe(\"Text\")\n\t\texpect(newNode.style?.position).toBe(\"absolute\")\n\t\texpect(newNode.style?.fontSize).toBe(16)\n\t})\n\n\tit(\"텍스트 노드 생성 후 select 도구로 자동 전환\", () => {\n\t\tconst tool = new TextTool()\n\t\tuseEditorStore.getState().setActiveTool(\"text\")\n\t\t\n\t\ttool.onPointerDown({ x: 100, y: 100, targetNodeId: null, /* ... */ })\n\t\t\n\t\texpect(useEditorStore.getState().activeTool).toBe(\"select\")\n\t})\n\n\tit(\"Zoom 적용 시 올바른 좌표에 생성\", () => {\n\t\tuseEditorStore.getState().setZoom(2)\n\t\tconst tool = new TextTool()\n\t\t\n\t\ttool.onPointerDown({ x: 200, y: 400, targetNodeId: null, /* ... */ })\n\t\t\n\t\tconst nodes = useEditorStore.getState().document.children[0].children\n\t\tconst newNode = nodes[nodes.length - 1]\n\t\t\n\t\texpect(newNode.style?.left).toBe(100) // 200 / 2\n\t\texpect(newNode.style?.top).toBe(200)  // 400 / 2\n\t})\n})\n```\n\n**2. 통합 테스트 (Playwright E2E)**\n```typescript\ntest(\"Text 도구로 텍스트 노드 생성\", async ({ page }) => {\n\t// 1. Text 도구 선택\n\tawait page.click('[title=\"Text\"]')\n\t\n\t// 2. Canvas의 빈 공간 클릭\n\tconst canvas = page.locator(\".canvas-app\")\n\tawait canvas.click({ position: { x: 300, y: 200 } })\n\t\n\t// 3. 텍스트 노드 생성 확인\n\tconst textNode = page.locator('[data-node-id^=\"text-\"]')\n\tawait expect(textNode).toBeVisible()\n\tawait expect(textNode).toHaveText(\"Text\")\n\t\n\t// 4. select 도구로 자동 전환 확인\n\tconst selectButton = page.locator('[title=\"Select\"]')\n\tawait expect(selectButton).toHaveClass(/active/)\n\t\n\t// 5. 생성된 노드가 선택 상태인지 확인\n\tawait expect(textNode).toHaveClass(/selected/)\n})\n\ntest(\"Text 도구 단축키 't' 작동\", async ({ page }) => {\n\tawait page.keyboard.press(\"t\")\n\t\n\tconst textButton = page.locator('[title=\"Text\"]')\n\tawait expect(textButton).toHaveClass(/active/)\n})\n\ntest(\"기존 노드 클릭 시 텍스트 노드 생성 안 됨\", async ({ page }) => {\n\tawait page.click('[title=\"Text\"]')\n\t\n\t// 기존 노드 클릭\n\tconst existingNode = page.locator('[data-node-id=\"node-1\"]')\n\tawait existingNode.click()\n\t\n\t// 텍스트 노드가 추가로 생성되지 않았는지 확인\n\tconst textNodes = page.locator('[data-node-id^=\"text-\"]')\n\tconst initialCount = await textNodes.count()\n\t\n\t// 한 번 더 클릭\n\tawait existingNode.click()\n\t\n\tconst finalCount = await textNodes.count()\n\texpect(finalCount).toBe(initialCount)\n})\n```\n\n**3. 수동 테스트 체크리스트**\n- [ ] 툴바에서 Text 도구 버튼 클릭 → 활성화 상태로 변경\n- [ ] 단축키 't' 입력 → Text 도구 활성화\n- [ ] Canvas의 빈 공간 클릭 → 텍스트 노드 생성\n- [ ] 생성된 텍스트 노드가 \"Text\" 기본 텍스트 포함\n- [ ] 생성된 노드가 클릭 위치에 정확히 배치\n- [ ] 생성 직후 노드가 선택 상태로 표시\n- [ ] 생성 후 자동으로 select 도구로 전환\n- [ ] Zoom 50%/200% 상태에서도 올바른 위치에 생성\n- [ ] 기존 노드 위를 클릭 시 새 텍스트 노드 생성되지 않음\n- [ ] 레이어 패널에 생성된 텍스트 노드 표시",
				"status": "done",
				"dependencies": ["11"],
				"priority": "high",
				"subtasks": [],
				"updatedAt": "2026-01-31T07:52:52.658Z"
			},
			{
				"id": "14",
				"title": "키보드 단축키 시스템 구현",
				"description": "Canvas와 Shell에서 전달되는 키보드 이벤트를 처리하여 Delete/Backspace(노드 삭제), Ctrl+Z/Y(Undo/Redo), Ctrl+D(복제), V/F/T/R(도구 전환), Escape(선택 해제) 단축키를 동작시키는 기능을 구현합니다.",
				"details": "**현재 상태 분석:**\n- Canvas에서 키보드 이벤트 캡처 완료 (`editor-canvas/src/App.tsx:62-93`)\n- Shell에서 키보드 이벤트 캡처 완료 (`editor-shell/src/App.tsx:107-134`)\n- EventRouter가 키보드 이벤트를 처리 (`editor-shell/src/events/EventRouter.ts:61-72`)\n- KeybindingRegistry가 이벤트 매칭 및 Command 실행 담당 (`editor-shell/src/keybindings/KeybindingRegistry.ts`)\n- 기본 키바인딩 정의 완료 (`editor-shell/src/keybindings/defaults.ts`)\n- Command 등록 완료:\n  - `history:undo`, `history:redo` (`commands/history.ts:8-14`)\n  - `node:delete`, `node:duplicate` (`commands/node.ts:8-21`)\n  - `tool:select`, `tool:frame`, `tool:text`, `tool:shape` (`commands/tool.ts:8-23`)\n  - `selection:clear` (`commands/selection.ts:8-10`)\n- 모든 Command는 `registerAllCommands()` (`commands/index.ts`)에서 등록됨\n- Zustand temporal 사용으로 Undo/Redo 준비 완료 (`store/editor.ts:584`)\n\n**문제 분석:**\nEventRouter는 키보드 이벤트를 받아 KeybindingRegistry에 전달하고, 매칭된 Command를 실행하는 로직이 이미 구현되어 있습니다. 그러나 현재 단축키가 동작하지 않는 이유는:\n\n1. **이벤트 전파 방지 누락**: 브라우저 기본 동작(Ctrl+Z 등)이 우선 실행될 수 있음\n2. **Tool 전환 시 preventDefault 누락**: 텍스트 입력 상태에서 단축키가 문자로 입력될 수 있음\n3. **디버깅 로그 부재**: 키바인딩 매칭 실패 시 원인 파악 불가\n\n**구현 단계:**\n\n**1. EventRouter에 preventDefault 및 로깅 추가**\n\n`packages/editor-shell/src/events/EventRouter.ts`의 `handleKeyDown` 메서드 수정:\n\n```typescript\nprivate handleKeyDown(e: CanvasKeyEvent): void {\n\tconsole.log(\"[EventRouter] KeyDown:\", {\n\t\tkey: e.key,\n\t\tcode: e.code,\n\t\tmeta: e.metaKey,\n\t\tctrl: e.ctrlKey,\n\t\tshift: e.shiftKey,\n\t\talt: e.altKey,\n\t})\n\n\t// 1. Keybinding 매칭 시도\n\tconst commandId = keybindingRegistry.match(e)\n\tif (commandId) {\n\t\tconsole.log(\"[EventRouter] Command 매칭:\", commandId)\n\t\tcommandRegistry.execute(commandId)\n\t\t// 브라우저 기본 동작 방지 (중요!)\n\t\t// 실제 DOM 이벤트 preventDefault는 Shell/Canvas에서 수행 필요\n\t\treturn\n\t}\n\n\tconsole.log(\"[EventRouter] Command 매칭 실패, Tool에 위임\")\n\n\t// 2. 매칭 안되면 현재 Tool에 위임\n\tconst tool = toolRegistry.getActiveTool()\n\ttool?.onKeyDown(e)\n}\n```\n\n**2. Shell에서 preventDefault 처리**\n\n`packages/editor-shell/src/App.tsx`의 `handleKeyDown`에 preventDefault 추가:\n\n```typescript\nconst handleKeyDown = (e: KeyboardEvent) => {\n\t// iframe 내부에서 발생한 이벤트는 무시 (Canvas에서 별도 처리)\n\tif ((e.target as HTMLElement)?.tagName === \"IFRAME\") return\n\n\tconst keyEvent: CanvasKeyEvent = {\n\t\ttype: \"keydown\" as const,\n\t\tkey: e.key,\n\t\tcode: e.code,\n\t\tshiftKey: e.shiftKey,\n\t\tctrlKey: e.ctrlKey,\n\t\tmetaKey: e.metaKey,\n\t\taltKey: e.altKey,\n\t}\n\n\t// Keybinding 매칭 여부 미리 확인\n\tconst commandId = keybindingRegistry.match(keyEvent)\n\tif (commandId) {\n\t\te.preventDefault() // 브라우저 기본 동작 방지\n\t\te.stopPropagation()\n\t}\n\n\teventBus.dispatch(EventTypes.SHELL_KEY_DOWN, keyEvent)\n}\n```\n\n**3. Canvas에서 preventDefault 처리**\n\n`packages/editor-canvas/src/App.tsx`의 `handleKeyDown`에 preventDefault 추가:\n\n```typescript\nconst handleKeyDown = (e: KeyboardEvent) => {\n\tconst keyEvent = {\n\t\ttype: \"keydown\" as const,\n\t\tkey: e.key,\n\t\tcode: e.code,\n\t\tshiftKey: e.shiftKey,\n\t\tctrlKey: e.ctrlKey,\n\t\tmetaKey: e.metaKey,\n\t\taltKey: e.altKey,\n\t}\n\n\t// 특정 키는 항상 preventDefault (단축키로 사용)\n\tconst preventKeys = [\n\t\t\"Delete\",\n\t\t\"Backspace\",\n\t\t\"Escape\",\n\t\t\"v\", \"f\", \"t\", \"r\" // Tool 전환 키\n\t]\n\t\n\tconst isModifierCombo = (e.metaKey || e.ctrlKey) && [\"z\", \"y\", \"d\"].includes(e.key.toLowerCase())\n\t\n\tif (preventKeys.includes(e.key) || isModifierCombo) {\n\t\te.preventDefault()\n\t\te.stopPropagation()\n\t}\n\n\tparentMethodsRef.current?.onCanvasKeyEvent(keyEvent)\n}\n```\n\n**4. KeybindingRegistry에 디버깅 로그 추가**\n\n`packages/editor-shell/src/keybindings/KeybindingRegistry.ts`의 `match` 메서드 수정:\n\n```typescript\nmatch(e: KeyEventLike): string | null {\n\tconst binding = this.bindings.find((b) => {\n\t\tconst keyMatch = b.key.toLowerCase() === e.key.toLowerCase()\n\t\tconst metaMatch = !!b.modifiers.meta === (e.metaKey || e.ctrlKey)\n\t\tconst shiftMatch = !!b.modifiers.shift === e.shiftKey\n\t\tconst altMatch = !!b.modifiers.alt === e.altKey\n\t\tconst conditionMatch = this.checkCondition(b.when)\n\n\t\tconst allMatch = keyMatch && metaMatch && shiftMatch && altMatch && conditionMatch\n\n\t\tif (keyMatch && !allMatch) {\n\t\t\tconsole.log(\"[KeybindingRegistry] 부분 매칭:\", {\n\t\t\t\tcommand: b.command,\n\t\t\t\tkeyMatch,\n\t\t\t\tmetaMatch,\n\t\t\t\tshiftMatch,\n\t\t\t\taltMatch,\n\t\t\t\tconditionMatch,\n\t\t\t\tcondition: b.when,\n\t\t\t})\n\t\t}\n\n\t\treturn allMatch\n\t})\n\n\treturn binding?.command ?? null\n}\n```\n\n**5. Command 실행 검증**\n\n`packages/editor-shell/src/commands/CommandRegistry.ts`에 로그 추가:\n\n```typescript\nexecute(commandId: string): void {\n\tconst command = this.commands.get(commandId)\n\tif (!command) {\n\t\tconsole.warn(`[CommandRegistry] Command not found: ${commandId}`)\n\t\treturn\n\t}\n\n\tconsole.log(`[CommandRegistry] Executing: ${commandId}`)\n\tcommand()\n}\n```\n\n**6. 단축키별 동작 확인 사항:**\n\n- **Delete/Backspace**: `node:delete` → `useEditorStore.getState().removeNode()` 호출 (이미 구현됨)\n- **Ctrl+Z (Cmd+Z)**: `history:undo` → `useEditorStore.temporal.getState().undo()` 호출 (이미 구현됨)\n- **Ctrl+Y/Cmd+Shift+Z**: `history:redo` → `useEditorStore.temporal.getState().redo()` 호출 (이미 구현됨)\n- **Ctrl+D (Cmd+D)**: `node:duplicate` → `useEditorStore.getState().duplicateNode()` 호출 (이미 구현됨)\n- **V**: `tool:select` → `toolRegistry.setActiveTool(\"select\")` 호출 (이미 구현됨)\n- **F**: `tool:frame` → `toolRegistry.setActiveTool(\"frame\")` 호출 (Task 11 필요)\n- **T**: `tool:text` → `toolRegistry.setActiveTool(\"text\")` 호출 (Task 13 필요)\n- **R**: `tool:shape` → `toolRegistry.setActiveTool(\"shape\")` 호출 (Task 12 필요)\n- **Escape**: `selection:clear` → `useEditorStore.getState().setSelection([])` 호출 (이미 구현됨)\n\n**7. 키보드 포커스 보장**\n\nCanvas iframe이 포커스를 받도록 초기화 시 처리:\n\n`packages/editor-shell/src/App.tsx`에서 iframe 마운트 후:\n\n```typescript\ncanvasConnection.promise.then((child) => {\n\tcanvasRef.current = child\n\t// 초기 상태 동기화\n\tconst state = useEditorStore.getState()\n\tchild.syncState({\n\t\tdocument: state.document,\n\t\tcurrentPageId: state.currentPageId,\n\t\tcomponents: state.components,\n\t\tzoom: state.zoom,\n\t\tselection: state.selection,\n\t\tactiveTool: state.activeTool,\n\t})\n\t\n\t// Canvas에 포커스 설정 (키보드 이벤트 수신 보장)\n\tsetTimeout(() => {\n\t\tiframeRef.current?.focus()\n\t}, 100)\n})\n```\n\n**8. 텍스트 입력 중 단축키 방지**\n\n`packages/editor-canvas/src/App.tsx`에서 input/textarea 포커스 시 Tool 단축키 무시:\n\n```typescript\nconst handleKeyDown = (e: KeyboardEvent) => {\n\t// 텍스트 입력 중에는 단일 문자 단축키 무시\n\tconst target = e.target as HTMLElement\n\tconst isTextInput = target.tagName === \"INPUT\" || \n\t                   target.tagName === \"TEXTAREA\" || \n\t                   target.isContentEditable\n\n\tconst isSingleCharShortcut = [\"v\", \"f\", \"t\", \"r\"].includes(e.key.toLowerCase()) && \n\t                            !e.metaKey && !e.ctrlKey\n\n\tif (isTextInput && isSingleCharShortcut) {\n\t\treturn // 단축키 실행 안 함\n\t}\n\n\t// ... 나머지 로직\n}\n```\n\n**주요 포인트:**\n- EventRouter, KeybindingRegistry, CommandRegistry는 이미 올바르게 구현됨\n- 문제는 브라우저 기본 동작이 우선 실행되는 것\n- **해결책**: Shell과 Canvas에서 `preventDefault()` 추가\n- 디버깅 로그로 매칭 실패 원인 추적 가능\n- Task 11, 12, 13 완료 시 F/T/R 단축키 활성화됨",
				"testStrategy": "**테스트 전략:**\n\n**1. 단위 테스트 (`vitest/keybindings/KeybindingRegistry.test.ts`)**\n```typescript\ndescribe(\"KeybindingRegistry\", () => {\n\tit(\"Ctrl+Z → history:undo 매칭\", () => {\n\t\tconst commandId = keybindingRegistry.match({\n\t\t\tkey: \"z\",\n\t\t\tmetaKey: true,\n\t\t\tshiftKey: false,\n\t\t\taltKey: false,\n\t\t\tctrlKey: false,\n\t\t\tcode: \"KeyZ\",\n\t\t})\n\t\texpect(commandId).toBe(\"history:undo\")\n\t})\n\n\tit(\"Delete → node:delete 매칭 (선택 있을 때)\", () => {\n\t\tuseEditorStore.setState({ selection: [\"node-1\"] })\n\t\tconst commandId = keybindingRegistry.match({\n\t\t\tkey: \"Delete\",\n\t\t\tmetaKey: false,\n\t\t\tshiftKey: false,\n\t\t\taltKey: false,\n\t\t\tctrlKey: false,\n\t\t\tcode: \"Delete\",\n\t\t})\n\t\texpect(commandId).toBe(\"node:delete\")\n\t})\n\n\tit(\"Delete → null (선택 없을 때)\", () => {\n\t\tuseEditorStore.setState({ selection: [] })\n\t\tconst commandId = keybindingRegistry.match({\n\t\t\tkey: \"Delete\",\n\t\t\tmetaKey: false,\n\t\t\tshiftKey: false,\n\t\t\taltKey: false,\n\t\t\tctrlKey: false,\n\t\t\tcode: \"Delete\",\n\t\t})\n\t\texpect(commandId).toBeNull()\n\t})\n\n\tit(\"v → tool:select 매칭\", () => {\n\t\tconst commandId = keybindingRegistry.match({\n\t\t\tkey: \"v\",\n\t\t\tmetaKey: false,\n\t\t\tshiftKey: false,\n\t\t\taltKey: false,\n\t\t\tctrlKey: false,\n\t\t\tcode: \"KeyV\",\n\t\t})\n\t\texpect(commandId).toBe(\"tool:select\")\n\t})\n\n\tit(\"Escape → selection:clear 매칭\", () => {\n\t\tconst commandId = keybindingRegistry.match({\n\t\t\tkey: \"Escape\",\n\t\t\tmetaKey: false,\n\t\t\tshiftKey: false,\n\t\t\taltKey: false,\n\t\t\tctrlKey: false,\n\t\t\tcode: \"Escape\",\n\t\t})\n\t\texpect(commandId).toBe(\"selection:clear\")\n\t})\n})\n```\n\n**2. 통합 테스트 (Playwright E2E)**\n\n`e2e/keyboard-shortcuts.spec.ts`:\n```typescript\ntest.describe(\"키보드 단축키\", () => {\n\ttest.beforeEach(async ({ page }) => {\n\t\tawait page.goto(\"http://localhost:3000\")\n\t\tawait page.waitForSelector(\".canvas-iframe\")\n\t\tconst frame = page.frameLocator(\".canvas-iframe\")\n\t\tawait frame.locator(\"[data-node-id]\").first().waitFor()\n\t})\n\n\ttest(\"Delete 키로 노드 삭제\", async ({ page }) => {\n\t\tconst frame = page.frameLocator(\".canvas-iframe\")\n\t\t\n\t\t// 노드 선택\n\t\tawait frame.locator(\"[data-node-id='text-1']\").click()\n\t\tawait page.waitForTimeout(100)\n\t\t\n\t\t// Delete 키 입력\n\t\tawait page.keyboard.press(\"Delete\")\n\t\tawait page.waitForTimeout(100)\n\t\t\n\t\t// 노드가 사라졌는지 확인\n\t\tconst nodeCount = await frame.locator(\"[data-node-id='text-1']\").count()\n\t\texpect(nodeCount).toBe(0)\n\t})\n\n\ttest(\"Ctrl+Z로 Undo\", async ({ page }) => {\n\t\tconst frame = page.frameLocator(\".canvas-iframe\")\n\t\t\n\t\t// 노드 삭제\n\t\tawait frame.locator(\"[data-node-id='text-1']\").click()\n\t\tawait page.keyboard.press(\"Delete\")\n\t\tawait page.waitForTimeout(100)\n\t\t\n\t\t// Undo\n\t\tconst modifier = process.platform === \"darwin\" ? \"Meta\" : \"Control\"\n\t\tawait page.keyboard.press(`${modifier}+z`)\n\t\tawait page.waitForTimeout(100)\n\t\t\n\t\t// 노드가 복원되었는지 확인\n\t\tconst nodeCount = await frame.locator(\"[data-node-id='text-1']\").count()\n\t\texpect(nodeCount).toBe(1)\n\t})\n\n\ttest(\"Ctrl+D로 노드 복제\", async ({ page }) => {\n\t\tconst frame = page.frameLocator(\".canvas-iframe\")\n\t\t\n\t\t// 노드 선택\n\t\tawait frame.locator(\"[data-node-id='text-1']\").click()\n\t\tconst initialCount = await frame.locator(\"[data-node-id^='p-']\").count()\n\t\t\n\t\t// 복제\n\t\tconst modifier = process.platform === \"darwin\" ? \"Meta\" : \"Control\"\n\t\tawait page.keyboard.press(`${modifier}+d`)\n\t\tawait page.waitForTimeout(100)\n\t\t\n\t\t// 노드가 1개 증가했는지 확인\n\t\tconst newCount = await frame.locator(\"[data-node-id^='p-']\").count()\n\t\texpect(newCount).toBe(initialCount + 1)\n\t})\n\n\ttest(\"V 키로 Select 도구 전환\", async ({ page }) => {\n\t\t// Frame 도구로 먼저 전환 (Task 11 필요)\n\t\tawait page.locator(\"button[title='Frame']\").click()\n\t\tawait page.waitForTimeout(100)\n\t\t\n\t\t// V 키로 Select 도구 전환\n\t\tawait page.keyboard.press(\"v\")\n\t\tawait page.waitForTimeout(100)\n\t\t\n\t\t// Select 버튼이 활성화되었는지 확인\n\t\tconst selectBtn = page.locator(\"button[title='Select']\")\n\t\tawait expect(selectBtn).toHaveClass(/active/)\n\t})\n\n\ttest(\"Escape로 선택 해제\", async ({ page }) => {\n\t\tconst frame = page.frameLocator(\".canvas-iframe\")\n\t\t\n\t\t// 노드 선택\n\t\tawait frame.locator(\"[data-node-id='text-1']\").click()\n\t\tawait page.waitForTimeout(100)\n\t\t\n\t\t// 선택된 노드 확인 (outline 스타일 등)\n\t\tconst selectedNode = frame.locator(\"[data-node-id='text-1']\")\n\t\t// (선택 상태 스타일 확인 로직)\n\t\t\n\t\t// Escape로 선택 해제\n\t\tawait page.keyboard.press(\"Escape\")\n\t\tawait page.waitForTimeout(100)\n\t\t\n\t\t// 선택이 해제되었는지 확인 (LayersPanel 등)\n\t\tconst selection = await page.evaluate(() => {\n\t\t\treturn (window as any).__editorStore?.getState().selection\n\t\t})\n\t\texpect(selection).toEqual([])\n\t})\n\n\ttest(\"F 키로 Frame 도구 전환 (Task 11 후)\", async ({ page }) => {\n\t\tawait page.keyboard.press(\"f\")\n\t\tawait page.waitForTimeout(100)\n\t\t\n\t\tconst frameBtn = page.locator(\"button[title='Frame']\")\n\t\tawait expect(frameBtn).toHaveClass(/active/)\n\t})\n\n\ttest(\"T 키로 Text 도구 전환 (Task 13 후)\", async ({ page }) => {\n\t\tawait page.keyboard.press(\"t\")\n\t\tawait page.waitForTimeout(100)\n\t\t\n\t\tconst textBtn = page.locator(\"button[title='Text']\")\n\t\tawait expect(textBtn).toHaveClass(/active/)\n\t})\n\n\ttest(\"R 키로 Shape 도구 전환 (Task 12 후)\", async ({ page }) => {\n\t\tawait page.keyboard.press(\"r\")\n\t\tawait page.waitForTimeout(100)\n\t\t\n\t\tconst shapeBtn = page.locator(\"button[title='Shape']\")\n\t\tawait expect(shapeBtn).toHaveClass(/active/)\n\t})\n\n\ttest(\"텍스트 입력 중에는 단일 문자 단축키 무시\", async ({ page }) => {\n\t\t// (Task 13 후 텍스트 노드 편집 시나리오)\n\t\t// input/textarea에 포커스 → \"v\" 입력 → 도구 전환 안 됨 확인\n\t})\n})\n```\n\n**3. 수동 테스트 체크리스트:**\n- [ ] Canvas에 포커스 후 Delete 키 → 선택 노드 삭제\n- [ ] Backspace 키 → 선택 노드 삭제\n- [ ] Ctrl+Z (Cmd+Z) → Undo 동작\n- [ ] Ctrl+Y (Cmd+Shift+Z) → Redo 동작\n- [ ] Ctrl+D (Cmd+D) → 노드 복제\n- [ ] V 키 → Select 도구 활성화\n- [ ] F 키 → Frame 도구 활성화 (Task 11 후)\n- [ ] T 키 → Text 도구 활성화 (Task 13 후)\n- [ ] R 키 → Shape 도구 활성화 (Task 12 후)\n- [ ] Escape → 선택 해제\n- [ ] 브라우저 콘솔에서 키바인딩 매칭 로그 확인\n- [ ] 선택 없을 때 Delete/Backspace → 아무 동작 안 함\n- [ ] 텍스트 입력 중 V/F/T/R 키 → 문자 입력됨 (도구 전환 안 됨)\n\n**4. 성능 테스트:**\n- 키 입력 → Command 실행까지 지연 시간 < 50ms\n- 연속된 키 입력 (Ctrl+Z 여러 번) → 정상 동작\n\n**5. 엣지 케이스:**\n- 여러 노드 선택 후 Delete → 모두 삭제\n- Undo 스택 비었을 때 Ctrl+Z → 아무 동작 안 함\n- Redo 스택 비었을 때 Ctrl+Y → 아무 동작 안 함\n- iframe 외부(Toolbar, LayersPanel)에서 키 입력 → 동일하게 동작",
				"status": "pending",
				"dependencies": ["11"],
				"priority": "high",
				"subtasks": []
			},
			{
				"id": "15",
				"title": "클립보드 기반 복사/붙여넣기/잘라내기 기능 구현",
				"description": "에디터 스토어에 클립보드 상태를 추가하고, Ctrl/Cmd+C(복사), Ctrl/Cmd+V(붙여넣기), Ctrl/Cmd+X(잘라내기) 키보드 단축키를 통해 선택된 노드를 클립보드에 저장하고 현재 페이지에 붙여넣는 기능을 구현합니다.",
				"details": "**현재 상태 분석:**\n- EditorStore에 `duplicateNode` 메서드가 이미 구현됨 (`editor.ts:378-406`)\n- `cloneNodeWithNewIds` 헬퍼 함수로 노드 복제 및 새 ID 부여 (`editor.ts:115-127`)\n- 키보드 이벤트 핸들링 인프라 완성 (`KeybindingRegistry`, `EventRouter`)\n- Command 시스템 준비 완료 (`CommandRegistry`, `commands/node.ts`)\n- 기본 키바인딩 설정 파일 존재 (`keybindings/defaults.ts`)\n\n**구현 단계:**\n\n**1. EditorState에 클립보드 상태 추가**\n\n`packages/editor-core/src/types/editor.ts`의 `EditorState` 인터페이스에 추가:\n```typescript\nexport interface EditorState {\n\t// ... 기존 필드들\n\t\n\t/** 클립보드에 저장된 노드들 (복사/잘라내기) */\n\tclipboard: SceneNode[]\n}\n```\n\n**2. EditorStore에 클립보드 관련 액션 추가**\n\n`packages/editor-core/src/types/editor.ts`의 `EditorActions` 인터페이스에 추가:\n```typescript\nexport interface EditorActions {\n\t// ... 기존 메서드들\n\t\n\t/** 선택된 노드를 클립보드에 복사 */\n\tcopyToClipboard: () => void\n\t\n\t/** 클립보드의 노드를 현재 페이지에 붙여넣기 */\n\tpasteFromClipboard: () => void\n\t\n\t/** 선택된 노드를 잘라내기 (복사 후 삭제) */\n\tcutToClipboard: () => void\n}\n```\n\n**3. EditorStore 구현 업데이트**\n\n`packages/editor-shell/src/store/editor.ts`에서 구현:\n\n```typescript\nexport const useEditorStore = create<EditorStore>()(\n\ttemporal(\n\t\t(set, get) => ({\n\t\t\t// 초기 상태\n\t\t\tdocument: initialDocument,\n\t\t\tcurrentPageId: initialPageId,\n\t\t\tcomponents: [],\n\t\t\tselection: [],\n\t\t\thoveredId: null,\n\t\t\tactiveTool: \"select\",\n\t\t\tzoom: 1,\n\t\t\tclipboard: [], // 추가\n\n\t\t\t// ... 기존 액션들\n\n\t\t\t/**\n\t\t\t * 선택된 노드를 클립보드에 복사\n\t\t\t */\n\t\t\tcopyToClipboard() {\n\t\t\t\tconst state = get()\n\t\t\t\tconst page = getCurrentPage(state.document, state.currentPageId)\n\t\t\t\tif (!page || state.selection.length === 0) return\n\n\t\t\t\tconst copiedNodes: SceneNode[] = []\n\t\t\t\tfor (const id of state.selection) {\n\t\t\t\t\tconst node = findNodeInPage(page, id)\n\t\t\t\t\tif (node) {\n\t\t\t\t\t\tcopiedNodes.push(node)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tset({ clipboard: copiedNodes })\n\t\t\t\tconsole.log(`[Clipboard] ${copiedNodes.length}개 노드 복사됨`)\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * 클립보드의 노드를 현재 페이지에 붙여넣기\n\t\t\t */\n\t\t\tpasteFromClipboard() {\n\t\t\t\tconst state = get()\n\t\t\t\tconst page = getCurrentPage(state.document, state.currentPageId)\n\t\t\t\tif (!page || state.clipboard.length === 0) return\n\n\t\t\t\tconst newIds: string[] = []\n\n\t\t\t\tfor (const node of state.clipboard) {\n\t\t\t\t\t// 노드 복제 및 새 ID 부여\n\t\t\t\t\tconst cloned = cloneNodeWithNewIds(node)\n\n\t\t\t\t\t// 위치 약간 이동 (20px 오프셋)\n\t\t\t\t\tif (cloned.style) {\n\t\t\t\t\t\tconst left = (cloned.style.left as number) ?? 0\n\t\t\t\t\t\tconst top = (cloned.style.top as number) ?? 0\n\t\t\t\t\t\tcloned.style = { ...cloned.style, left: left + 20, top: top + 20 }\n\t\t\t\t\t}\n\n\t\t\t\t\t// 현재 페이지에 추가\n\t\t\t\t\tstate.addNode(page.id, cloned)\n\t\t\t\t\tnewIds.push(cloned.id)\n\t\t\t\t}\n\n\t\t\t\t// 새로 붙여넣은 노드들 선택\n\t\t\t\tstate.setSelection(newIds)\n\t\t\t\tconsole.log(`[Clipboard] ${newIds.length}개 노드 붙여넣기 완료`)\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * 선택된 노드를 잘라내기 (복사 후 삭제)\n\t\t\t */\n\t\t\tcutToClipboard() {\n\t\t\t\tconst state = get()\n\t\t\t\tconst page = getCurrentPage(state.document, state.currentPageId)\n\t\t\t\tif (!page || state.selection.length === 0) return\n\n\t\t\t\t// 먼저 복사\n\t\t\t\tstate.copyToClipboard()\n\n\t\t\t\t// 그다음 삭제\n\t\t\t\tfor (const id of state.selection) {\n\t\t\t\t\tstate.removeNode(id)\n\t\t\t\t}\n\n\t\t\t\tstate.setSelection([])\n\t\t\t\tconsole.log(`[Clipboard] ${state.clipboard.length}개 노드 잘라내기 완료`)\n\t\t\t},\n\n\t\t\t// ... 나머지 기존 메서드들\n\t\t}),\n\t\t{\n\t\t\tpartialize: (state) => ({\n\t\t\t\tdocument: state.document,\n\t\t\t\tcomponents: state.components,\n\t\t\t\t// clipboard는 히스토리에서 제외 (임시 상태)\n\t\t\t}),\n\t\t\tlimit: 50,\n\t\t\tonSave: (pastState, currentState) => {\n\t\t\t\tconsole.log(\"[History] 저장됨\", {\n\t\t\t\t\tpastState,\n\t\t\t\t\tcurrentState,\n\t\t\t\t\tpastStates: useEditorStore.temporal.getState().pastStates.length,\n\t\t\t\t\tfutureStates: useEditorStore.temporal.getState().futureStates.length,\n\t\t\t\t})\n\t\t\t},\n\t\t},\n\t),\n)\n```\n\n**4. Command 등록**\n\n`packages/editor-shell/src/commands/node.ts`에 추가:\n```typescript\nexport function registerNodeCommands(): void {\n\t// ... 기존 Commands\n\n\tcommandRegistry.register(\"node:copy\", () => {\n\t\tuseEditorStore.getState().copyToClipboard()\n\t})\n\n\tcommandRegistry.register(\"node:paste\", () => {\n\t\tuseEditorStore.getState().pasteFromClipboard()\n\t})\n\n\tcommandRegistry.register(\"node:cut\", () => {\n\t\tuseEditorStore.getState().cutToClipboard()\n\t})\n}\n```\n\n**5. 키바인딩 추가**\n\n`packages/editor-shell/src/keybindings/defaults.ts`에 추가:\n```typescript\nexport const defaultKeybindings: Keybinding[] = [\n\t// ... 기존 키바인딩들\n\n\t// 클립보드\n\t{ key: \"c\", modifiers: { meta: true }, command: \"node:copy\", when: \"hasSelection\" },\n\t{ key: \"v\", modifiers: { meta: true }, command: \"node:paste\" },\n\t{ key: \"x\", modifiers: { meta: true }, command: \"node:cut\", when: \"hasSelection\" },\n]\n```\n\n**주의사항:**\n- `v` 키 단축키는 이미 Select 도구 전환에 사용 중 (`keybindings/defaults.ts:20`)\n- Cmd/Ctrl+V와 단순 V는 구분되므로 충돌 없음\n- 클립보드는 히스토리 상태에서 제외 (`partialize`에서 clipboard 미포함)\n- 붙여넣기 시 position이 absolute가 아닌 노드는 offset이 적용되지 않을 수 있음 (현재 `duplicateNode` 구현 방식과 동일)\n\n**Mac/Windows 호환성:**\n- `meta: true`는 Mac에서 Cmd, Windows/Linux에서 Ctrl 키로 자동 매핑됨\n- KeybindingRegistry가 자동으로 처리 (`KeybindingRegistry.ts`)",
				"testStrategy": "**테스트 전략:**\n\n**1. 단위 테스트 (`vitest/store/clipboard.test.ts`)**\n```typescript\ndescribe(\"Clipboard 기능\", () => {\n\tbeforeEach(() => {\n\t\tuseEditorStore.setState({\n\t\t\tdocument: createTestDocument(),\n\t\t\tselection: [\"node-1\", \"node-2\"],\n\t\t\tclipboard: [],\n\t\t})\n\t})\n\n\tit(\"copyToClipboard: 선택된 노드를 클립보드에 저장\", () => {\n\t\tconst store = useEditorStore.getState()\n\t\tstore.copyToClipboard()\n\t\t\n\t\texpect(store.clipboard).toHaveLength(2)\n\t\texpect(store.clipboard[0].id).toBe(\"node-1\")\n\t\texpect(store.clipboard[1].id).toBe(\"node-2\")\n\t})\n\n\tit(\"pasteFromClipboard: 클립보드 노드를 새 ID로 붙여넣기\", () => {\n\t\tconst store = useEditorStore.getState()\n\t\tstore.copyToClipboard()\n\t\t\n\t\tconst initialNodeCount = getCurrentPage().children.length\n\t\tstore.pasteFromClipboard()\n\t\t\n\t\tconst newNodeCount = getCurrentPage().children.length\n\t\texpect(newNodeCount).toBe(initialNodeCount + 2)\n\t\t\n\t\t// 새 노드의 ID가 원본과 다름\n\t\tconst newSelection = store.selection\n\t\texpect(newSelection).not.toContain(\"node-1\")\n\t\texpect(newSelection).not.toContain(\"node-2\")\n\t})\n\n\tit(\"pasteFromClipboard: 위치가 20px 오프셋됨\", () => {\n\t\tconst store = useEditorStore.getState()\n\t\tconst originalNode = store.findNode(\"node-1\")\n\t\tconst originalLeft = originalNode.style?.left ?? 0\n\t\tconst originalTop = originalNode.style?.top ?? 0\n\t\t\n\t\tstore.setSelection([\"node-1\"])\n\t\tstore.copyToClipboard()\n\t\tstore.pasteFromClipboard()\n\t\t\n\t\tconst pastedNode = store.findNode(store.selection[0])\n\t\texpect(pastedNode.style?.left).toBe(originalLeft + 20)\n\t\texpect(pastedNode.style?.top).toBe(originalTop + 20)\n\t})\n\n\tit(\"cutToClipboard: 복사 후 원본 삭제\", () => {\n\t\tconst store = useEditorStore.getState()\n\t\tconst initialNodeCount = getCurrentPage().children.length\n\t\t\n\t\tstore.cutToClipboard()\n\t\t\n\t\texpect(store.clipboard).toHaveLength(2)\n\t\texpect(getCurrentPage().children.length).toBe(initialNodeCount - 2)\n\t\texpect(store.selection).toHaveLength(0)\n\t})\n\n\tit(\"선택 없이 복사 시 동작 안 함\", () => {\n\t\tconst store = useEditorStore.getState()\n\t\tstore.setSelection([])\n\t\tstore.copyToClipboard()\n\t\t\n\t\texpect(store.clipboard).toHaveLength(0)\n\t})\n\n\tit(\"클립보드 비어있을 때 붙여넣기 시 동작 안 함\", () => {\n\t\tconst store = useEditorStore.getState()\n\t\tconst initialNodeCount = getCurrentPage().children.length\n\t\t\n\t\tstore.pasteFromClipboard()\n\t\t\n\t\texpect(getCurrentPage().children.length).toBe(initialNodeCount)\n\t})\n})\n```\n\n**2. 키보드 단축키 테스트 (`vitest/keybindings/clipboard.test.ts`)**\n```typescript\ndescribe(\"클립보드 키바인딩\", () => {\n\tit(\"Cmd+C → node:copy 매칭\", () => {\n\t\tconst commandId = keybindingRegistry.match({\n\t\t\tkey: \"c\",\n\t\t\tmetaKey: true,\n\t\t\tshiftKey: false,\n\t\t\taltKey: false,\n\t\t\tctrlKey: false,\n\t\t}, { hasSelection: true })\n\t\t\n\t\texpect(commandId).toBe(\"node:copy\")\n\t})\n\n\tit(\"Cmd+V → node:paste 매칭\", () => {\n\t\tconst commandId = keybindingRegistry.match({\n\t\t\tkey: \"v\",\n\t\t\tmetaKey: true,\n\t\t\tshiftKey: false,\n\t\t\taltKey: false,\n\t\t\tctrlKey: false,\n\t\t}, { hasSelection: false })\n\t\t\n\t\texpect(commandId).toBe(\"node:paste\")\n\t})\n\n\tit(\"Cmd+X → node:cut 매칭\", () => {\n\t\tconst commandId = keybindingRegistry.match({\n\t\t\tkey: \"x\",\n\t\t\tmetaKey: true,\n\t\t\tshiftKey: false,\n\t\t\taltKey: false,\n\t\t\tctrlKey: false,\n\t\t}, { hasSelection: true })\n\t\t\n\t\texpect(commandId).toBe(\"node:cut\")\n\t})\n\n\tit(\"단순 'v' 키 → tool:select 매칭 (클립보드와 충돌 없음)\", () => {\n\t\tconst commandId = keybindingRegistry.match({\n\t\t\tkey: \"v\",\n\t\t\tmetaKey: false,\n\t\t\tshiftKey: false,\n\t\t\taltKey: false,\n\t\t\tctrlKey: false,\n\t\t}, { hasSelection: false })\n\t\t\n\t\texpect(commandId).toBe(\"tool:select\")\n\t})\n})\n```\n\n**3. 통합 테스트 (E2E with Playwright)**\n```typescript\ntest(\"복사/붙여넣기 워크플로우\", async ({ page }) => {\n\t// 1. 에디터 로드\n\tawait page.goto(\"http://localhost:3000\")\n\t\n\t// 2. 노드 선택\n\tawait page.click('[data-node-id=\"root\"]')\n\t\n\t// 3. Cmd+C로 복사\n\tawait page.keyboard.press(\"Meta+C\")\n\t\n\t// 4. Cmd+V로 붙여넣기\n\tawait page.keyboard.press(\"Meta+V\")\n\t\n\t// 5. 새 노드가 생성되었는지 확인\n\tconst nodes = await page.locator('[data-node-id]').count()\n\texpect(nodes).toBeGreaterThan(1)\n\t\n\t// 6. 새 노드가 선택되었는지 확인\n\tconst selectedNodes = await page.locator('[data-selected=\"true\"]').count()\n\texpect(selectedNodes).toBe(1)\n})\n\ntest(\"잘라내기 워크플로우\", async ({ page }) => {\n\tawait page.goto(\"http://localhost:3000\")\n\t\n\tconst initialCount = await page.locator('[data-node-id]').count()\n\t\n\t// 노드 선택 후 잘라내기\n\tawait page.click('[data-node-id=\"text-1\"]')\n\tawait page.keyboard.press(\"Meta+X\")\n\t\n\t// 원본 노드 삭제 확인\n\tconst afterCutCount = await page.locator('[data-node-id]').count()\n\texpect(afterCutCount).toBe(initialCount - 1)\n\t\n\t// 붙여넣기\n\tawait page.keyboard.press(\"Meta+V\")\n\t\n\t// 노드 개수 원복 확인\n\tconst afterPasteCount = await page.locator('[data-node-id]').count()\n\texpect(afterPasteCount).toBe(initialCount)\n})\n```\n\n**4. 수동 검증**\n1. Shell 실행: `cd packages/editor-shell && pnpm dev`\n2. 노드 선택 → Cmd+C (Mac) / Ctrl+C (Windows)\n3. 빈 공간 클릭 → Cmd+V / Ctrl+V\n4. 복제된 노드가 20px 오프셋되어 생성되는지 확인\n5. 새 노드가 자동 선택되는지 확인\n6. Cmd+X로 잘라내기 → 원본 삭제 확인 → Cmd+V로 붙여넣기\n7. 여러 노드 선택 (Shift+클릭) → Cmd+C → Cmd+V → 모두 복제되는지 확인\n8. DevTools Console에서 \"[Clipboard]\" 로그 확인",
				"status": "pending",
				"dependencies": ["14"],
				"priority": "medium",
				"subtasks": []
			},
			{
				"id": "16",
				"title": "다중 선택 및 범위 선택(Marquee Selection) 기능 구현",
				"description": "현재 단일 선택만 가능한 에디터에 Shift+클릭 다중 선택, 빈 캔버스 드래그를 통한 범위 선택(Marquee), Ctrl/Cmd+A 전체 선택 기능을 추가하고, 선택된 여러 노드의 동시 이동/삭제를 지원합니다.",
				"details": "**현재 상태 분석:**\n- 단일 선택 및 Shift+클릭 토글 기능 이미 구현됨 (`SelectTool.ts:15-19`)\n- `toggleSelection` 메서드로 다중 선택 추가/제거 가능 (`editor.ts:301-310`)\n- `selection: string[]` 배열로 다중 선택 상태 관리 (`editor.ts:191`)\n- Canvas 마우스 이벤트 핸들링 인프라 존재 (`editor-canvas/src/App.tsx:114-230`)\n- 키보드 단축키 시스템 준비 완료 (`KeybindingRegistry`, `defaults.ts`)\n- `selection:clear` 커맨드 등록됨 (`commands/selection.ts:8-10`)\n- 다중 노드 방향키 이동 이미 구현됨 (`SelectTool.ts:51-88`)\n\n**구현 단계:**\n\n**1. 전체 선택 커맨드 구현**\n\n`packages/editor-shell/src/commands/selection.ts`에 `selection:all` 추가:\n```typescript\nimport { useEditorStore } from \"../store/editor\"\nimport { commandRegistry } from \"./CommandRegistry\"\n\nexport function registerSelectionCommands(): void {\n\tcommandRegistry.register(\"selection:clear\", () => {\n\t\tuseEditorStore.getState().setSelection([])\n\t})\n\n\tcommandRegistry.register(\"selection:all\", () => {\n\t\tconst { document, currentPageId } = useEditorStore.getState()\n\t\tconst page = document.children.find((p) => p.id === currentPageId)\n\t\tif (!page) return\n\n\t\t// 페이지의 모든 최상위 노드 ID 수집\n\t\tconst allNodeIds = page.children.map((node) => node.id)\n\t\tuseEditorStore.getState().setSelection(allNodeIds)\n\t})\n}\n```\n\n**2. Ctrl/Cmd+A 키바인딩 추가**\n\n`packages/editor-shell/src/keybindings/defaults.ts`에 추가:\n```typescript\nexport const defaultKeybindings: Keybinding[] = [\n\t// ... 기존 키바인딩들\n\n\t// Selection\n\t{ key: \"Escape\", modifiers: {}, command: \"selection:clear\" },\n\t{ key: \"a\", modifiers: { meta: true }, command: \"selection:all\" },  // ← 추가\n]\n```\n\n**3. Marquee Selection 상태 추가**\n\n`packages/editor-core/src/types/editor.ts`의 `EditorState`에 marquee 상태 추가:\n```typescript\nexport interface EditorState {\n\t// ... 기존 필드들\n\t\n\t/** Marquee 선택 영역 (드래그 범위 선택) */\n\tmarqueeBox: { x: number; y: number; width: number; height: number } | null\n}\n```\n\n`packages/editor-shell/src/store/editor.ts`에 초기값 및 액션 추가:\n```typescript\nexport const useEditorStore = create<EditorStore>()(\n\ttemporal((set, get) => ({\n\t\t// 초기 상태\n\t\t// ...\n\t\tmarqueeBox: null,\n\n\t\tsetMarqueeBox(box: { x: number; y: number; width: number; height: number } | null) {\n\t\t\tset({ marqueeBox: box })\n\t\t},\n```\n\n**4. SelectTool에 Marquee Selection 로직 추가**\n\n`packages/editor-shell/src/tools/SelectTool.ts` 수정:\n```typescript\nexport class SelectTool extends BaseTool {\n\toverride name = \"select\"\n\toverride cursor = \"default\"\n\n\t// Marquee 드래그 시작점 추적\n\tprivate marqueeStart: { x: number; y: number } | null = null\n\n\toverride onPointerDown(e: CanvasPointerEvent): void {\n\t\tif (e.targetNodeId) {\n\t\t\t// 노드 클릭 → 선택\n\t\t\tif (e.shiftKey) {\n\t\t\t\tuseEditorStore.getState().toggleSelection(e.targetNodeId)\n\t\t\t} else {\n\t\t\t\tuseEditorStore.getState().setSelection([e.targetNodeId])\n\t\t\t}\n\n\t\t\t// 드래그 시작 (히스토리 일시정지)\n\t\t\tuseEditorStore.temporal.getState().pause()\n\t\t} else {\n\t\t\t// 빈 공간 클릭 → Marquee 시작\n\t\t\tif (!e.shiftKey) {\n\t\t\t\tuseEditorStore.getState().setSelection([])\n\t\t\t}\n\t\t\tthis.marqueeStart = { x: e.x, y: e.y }\n\t\t}\n\t}\n\n\toverride onPointerMove(e: CanvasPointerEvent): void {\n\t\t// Marquee 드래그 중\n\t\tif (this.marqueeStart && !e.targetNodeId) {\n\t\t\tconst x = Math.min(this.marqueeStart.x, e.x)\n\t\t\tconst y = Math.min(this.marqueeStart.y, e.y)\n\t\t\tconst width = Math.abs(e.x - this.marqueeStart.x)\n\t\t\tconst height = Math.abs(e.y - this.marqueeStart.y)\n\n\t\t\tuseEditorStore.getState().setMarqueeBox({ x, y, width, height })\n\n\t\t\t// 교차하는 노드 찾기\n\t\t\tconst intersectingIds = this.getIntersectingNodes({ x, y, width, height })\n\t\t\t\n\t\t\t// Shift 키 누른 경우 기존 선택 유지하며 추가\n\t\t\tif (e.shiftKey) {\n\t\t\t\tconst currentSelection = useEditorStore.getState().selection\n\t\t\t\tconst mergedSelection = [...new Set([...currentSelection, ...intersectingIds])]\n\t\t\t\tuseEditorStore.getState().setSelection(mergedSelection)\n\t\t\t} else {\n\t\t\t\tuseEditorStore.getState().setSelection(intersectingIds)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\t// 노드 드래그 이동 (기존 로직)\n\t\tif (e.nodeId && e.deltaX !== undefined && e.deltaY !== undefined) {\n\t\t\tconst selection = useEditorStore.getState().selection\n\t\t\t\n\t\t\t// 다중 선택된 노드 모두 이동\n\t\t\tfor (const nodeId of selection) {\n\t\t\t\tconst node = useEditorStore.getState().findNode(nodeId)\n\t\t\t\tif (node && !node.locked) {\n\t\t\t\t\tconst currentLeft = typeof node.style?.left === \"number\" ? node.style.left : 0\n\t\t\t\t\tconst currentTop = typeof node.style?.top === \"number\" ? node.style.top : 0\n\n\t\t\t\t\tuseEditorStore.getState().moveNode(nodeId, {\n\t\t\t\t\t\tx: currentLeft + e.deltaX,\n\t\t\t\t\t\ty: currentTop + e.deltaY,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\toverride onDragEnd(_e: DragEndEvent): void {\n\t\t// Marquee 종료\n\t\tif (this.marqueeStart) {\n\t\t\tthis.marqueeStart = null\n\t\t\tuseEditorStore.getState().setMarqueeBox(null)\n\t\t}\n\n\t\t// 드래그 완료 → 히스토리 재개\n\t\tuseEditorStore.temporal.getState().resume()\n\t}\n\n\t/**\n\t * Marquee 영역과 교차하는 노드 ID 목록 반환\n\t */\n\tprivate getIntersectingNodes(marquee: { x: number; y: number; width: number; height: number }): string[] {\n\t\tconst { document, currentPageId } = useEditorStore.getState()\n\t\tconst page = document.children.find((p) => p.id === currentPageId)\n\t\tif (!page) return []\n\n\t\tconst intersecting: string[] = []\n\n\t\tfor (const node of page.children) {\n\t\t\tif (this.isNodeIntersecting(node, marquee)) {\n\t\t\t\tintersecting.push(node.id)\n\t\t\t}\n\t\t}\n\n\t\treturn intersecting\n\t}\n\n\t/**\n\t * 노드가 Marquee 영역과 교차하는지 확인\n\t */\n\tprivate isNodeIntersecting(\n\t\tnode: SceneNode,\n\t\tmarquee: { x: number; y: number; width: number; height: number },\n\t): boolean {\n\t\tconst style = node.style\n\t\tif (!style) return false\n\n\t\tconst nodeLeft = (style.left as number) ?? 0\n\t\tconst nodeTop = (style.top as number) ?? 0\n\t\tconst nodeWidth = typeof style.width === \"number\" ? style.width : 0\n\t\tconst nodeHeight = typeof style.height === \"number\" ? style.height : 0\n\n\t\t// AABB 충돌 검사\n\t\treturn (\n\t\t\tnodeLeft < marquee.x + marquee.width &&\n\t\t\tnodeLeft + nodeWidth > marquee.x &&\n\t\t\tnodeTop < marquee.y + marquee.height &&\n\t\t\tnodeTop + nodeHeight > marquee.y\n\t\t)\n\t}\n\n\t// 기존 onKeyDown 메서드 유지 (다중 노드 방향키 이동)\n}\n```\n\n**5. Canvas에서 Marquee 박스 렌더링**\n\n`packages/editor-canvas/src/App.tsx`에 marquee 박스 렌더링 추가:\n```typescript\nexport function App() {\n\tconst [marqueeBox, setMarqueeBox] = useState<{ x: number; y: number; width: number; height: number } | null>(null)\n\t// ... 기존 상태들\n\n\tuseEffect(() => {\n\t\tconst connection = connectToParent<ShellMethods>({\n\t\t\tmethods: {\n\t\t\t\tsyncState(state: {\n\t\t\t\t\t// ... 기존 필드들\n\t\t\t\t\tmarqueeBox: { x: number; y: number; width: number; height: number } | null\n\t\t\t\t}) {\n\t\t\t\t\t// ... 기존 동기화 로직\n\t\t\t\t\tsetMarqueeBox(state.marqueeBox)\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\t// ...\n\t}, [])\n\n\treturn (\n\t\t<div className=\"canvas-app\" style={{ transform: `scale(${zoom})` }} /* ... */>\n\t\t\t<CanvasRenderer /* ... */ />\n\t\t\t\n\t\t\t{/* Marquee 선택 박스 렌더링 */}\n\t\t\t{marqueeBox && (\n\t\t\t\t<div\n\t\t\t\t\tclassName=\"marquee-box\"\n\t\t\t\t\tstyle={{\n\t\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\t\tleft: marqueeBox.x,\n\t\t\t\t\t\ttop: marqueeBox.y,\n\t\t\t\t\t\twidth: marqueeBox.width,\n\t\t\t\t\t\theight: marqueeBox.height,\n\t\t\t\t\t\tborder: \"1px dashed #007AFF\",\n\t\t\t\t\t\tbackgroundColor: \"rgba(0, 122, 255, 0.1)\",\n\t\t\t\t\t\tpointerEvents: \"none\",\n\t\t\t\t\t\tzIndex: 9999,\n\t\t\t\t\t}}\n\t\t\t\t/>\n\t\t\t)}\n\t\t</div>\n\t)\n}\n```\n\n**6. 다중 선택 노드 동시 삭제 지원**\n\n`packages/editor-shell/src/commands/node.ts`의 `node:delete` 수정:\n```typescript\ncommandRegistry.register(\"node:delete\", () => {\n\tconst selection = useEditorStore.getState().selection\n\t\n\t// 선택된 모든 노드 삭제\n\tfor (const id of selection) {\n\t\tuseEditorStore.getState().removeNode(id)\n\t}\n})\n```\n\n**7. EditorActions 타입에 setMarqueeBox 추가**\n\n`packages/editor-core/src/types/editor.ts`에 추가:\n```typescript\nexport interface EditorActions {\n\t// ... 기존 액션들\n\t\n\t/** Marquee 선택 영역 설정 */\n\tsetMarqueeBox: (box: { x: number; y: number; width: number; height: height } | null) => void\n}\n```\n\n**구현 고려사항:**\n- Marquee 드래그 중에는 노드 드래그 이동이 발생하지 않도록 분기 처리\n- Shift 키 누른 상태에서 Marquee 드래그 시 기존 선택 유지하며 추가 선택\n- 다중 노드 이동 시 locked 노드는 이동되지 않도록 필터링\n- Zoom 레벨에 따른 좌표 변환 고려 (현재는 Canvas 전체에 scale 적용되므로 별도 변환 불필요)\n- 교차 검사는 AABB (Axis-Aligned Bounding Box) 알고리즘 사용",
				"testStrategy": "**테스트 전략:**\n\n**1. 단위 테스트 (`vitest/selection/multi-selection.test.ts`)**\n```typescript\ndescribe(\"다중 선택 기능\", () => {\n\tbeforeEach(() => {\n\t\tuseEditorStore.setState({\n\t\t\tdocument: createTestDocument(),\n\t\t\tselection: [],\n\t\t})\n\t})\n\n\tit(\"Shift+클릭으로 기존 선택에 노드 추가\", () => {\n\t\tconst { toggleSelection, selection } = useEditorStore.getState()\n\t\t\n\t\ttoggleSelection(\"node-1\")\n\t\texpect(selection).toEqual([\"node-1\"])\n\t\t\n\t\ttoggleSelection(\"node-2\")\n\t\texpect(selection).toEqual([\"node-1\", \"node-2\"])\n\t})\n\n\tit(\"Shift+클릭으로 선택된 노드 제거\", () => {\n\t\tuseEditorStore.setState({ selection: [\"node-1\", \"node-2\"] })\n\t\t\n\t\tuseEditorStore.getState().toggleSelection(\"node-1\")\n\t\texpect(useEditorStore.getState().selection).toEqual([\"node-2\"])\n\t})\n\n\tit(\"Ctrl/Cmd+A로 페이지의 모든 노드 선택\", () => {\n\t\t// selection:all 커맨드 실행\n\t\tcommandRegistry.execute(\"selection:all\")\n\t\t\n\t\tconst { selection, document, currentPageId } = useEditorStore.getState()\n\t\tconst page = document.children.find((p) => p.id === currentPageId)\n\t\t\n\t\texpect(selection.length).toBe(page?.children.length ?? 0)\n\t\texpect(selection).toContain(\"root\")\n\t})\n\n\tit(\"다중 선택된 노드 동시 삭제\", () => {\n\t\tuseEditorStore.setState({ selection: [\"node-1\", \"node-2\"] })\n\t\t\n\t\tcommandRegistry.execute(\"node:delete\")\n\t\t\n\t\texpect(useEditorStore.getState().findNode(\"node-1\")).toBeNull()\n\t\texpect(useEditorStore.getState().findNode(\"node-2\")).toBeNull()\n\t\texpect(useEditorStore.getState().selection).toEqual([])\n\t})\n})\n\ndescribe(\"Marquee Selection\", () => {\n\tit(\"빈 캔버스 드래그 시 marqueeBox 생성\", () => {\n\t\tconst tool = new SelectTool()\n\t\t\n\t\ttool.onPointerDown({ x: 100, y: 100, targetNodeId: null, shiftKey: false, ... })\n\t\ttool.onPointerMove({ x: 200, y: 200, targetNodeId: null, ... })\n\t\t\n\t\tconst { marqueeBox } = useEditorStore.getState()\n\t\texpect(marqueeBox).toEqual({ x: 100, y: 100, width: 100, height: 100 })\n\t})\n\n\tit(\"Marquee 영역과 교차하는 노드 선택\", () => {\n\t\t// 노드 위치: (50, 50, 100x100), (200, 200, 100x100)\n\t\t// Marquee: (0, 0, 150x150)\n\t\t\n\t\ttool.onPointerDown({ x: 0, y: 0, targetNodeId: null, ... })\n\t\ttool.onPointerMove({ x: 150, y: 150, ... })\n\t\t\n\t\tconst { selection } = useEditorStore.getState()\n\t\texpect(selection).toContain(\"node-at-50-50\")\n\t\texpect(selection).not.toContain(\"node-at-200-200\")\n\t})\n\n\tit(\"Marquee 드래그 종료 시 marqueeBox null로 초기화\", () => {\n\t\ttool.onPointerDown({ x: 0, y: 0, targetNodeId: null, ... })\n\t\ttool.onPointerMove({ x: 100, y: 100, ... })\n\t\ttool.onDragEnd({ ... })\n\t\t\n\t\texpect(useEditorStore.getState().marqueeBox).toBeNull()\n\t})\n\n\tit(\"Shift+Marquee로 기존 선택 유지하며 추가 선택\", () => {\n\t\tuseEditorStore.setState({ selection: [\"existing-node\"] })\n\t\t\n\t\ttool.onPointerDown({ x: 0, y: 0, targetNodeId: null, shiftKey: true, ... })\n\t\ttool.onPointerMove({ x: 100, y: 100, shiftKey: true, ... })\n\t\t\n\t\tconst { selection } = useEditorStore.getState()\n\t\texpect(selection).toContain(\"existing-node\")\n\t\texpect(selection.length).toBeGreaterThan(1)\n\t})\n})\n```\n\n**2. E2E 테스트 (`tests/e2e/multi-selection.spec.ts`)**\n```typescript\ntest(\"Shift+클릭으로 여러 노드 선택 후 동시 이동\", async ({ page }) => {\n\tawait page.goto(\"http://localhost:3000\")\n\t\n\t// 첫 번째 노드 클릭 선택\n\tawait page.locator('[data-node-id=\"root\"]').click()\n\t\n\t// Shift+클릭으로 두 번째 노드 추가 선택\n\tawait page.keyboard.down(\"Shift\")\n\tawait page.locator('[data-node-id=\"text-1\"]').click()\n\tawait page.keyboard.up(\"Shift\")\n\t\n\t// 두 노드 모두 선택되었는지 확인\n\texpect(await page.locator(\".node-wrapper.selected\").count()).toBe(2)\n\t\n\t// 첫 번째 노드 드래그로 동시 이동\n\tawait page.locator('[data-node-id=\"root\"]').dragTo(\n\t\tpage.locator(\".canvas-app\"),\n\t\t{ targetPosition: { x: 500, y: 500 } }\n\t)\n\t\n\t// 두 노드 모두 이동되었는지 확인\n\t// (검증 로직 추가)\n})\n\ntest(\"빈 캔버스 드래그로 범위 선택 (Marquee)\", async ({ page }) => {\n\tawait page.goto(\"http://localhost:3000\")\n\t\n\t// 빈 공간에서 드래그 시작\n\tawait page.locator(\".canvas-app\").dispatchEvent(\"mousedown\", { clientX: 50, clientY: 50 })\n\tawait page.mouse.move(300, 300)\n\t\n\t// Marquee 박스 표시 확인\n\tconst marquee = page.locator(\".marquee-box\")\n\tawait expect(marquee).toBeVisible()\n\t\n\tawait page.mouse.up()\n\t\n\t// 범위 내 노드들 선택되었는지 확인\n\texpect(await page.locator(\".node-wrapper.selected\").count()).toBeGreaterThan(0)\n\t\n\t// Marquee 박스 사라졌는지 확인\n\tawait expect(marquee).not.toBeVisible()\n})\n\ntest(\"Ctrl/Cmd+A로 전체 선택\", async ({ page }) => {\n\tawait page.goto(\"http://localhost:3000\")\n\t\n\tconst isMac = process.platform === \"darwin\"\n\tconst modifier = isMac ? \"Meta\" : \"Control\"\n\t\n\tawait page.keyboard.press(`${modifier}+a`)\n\t\n\t// 페이지의 모든 최상위 노드 선택 확인\n\tconst totalNodes = await page.locator('[data-node-id]').count()\n\tconst selectedNodes = await page.locator(\".node-wrapper.selected\").count()\n\t\n\texpect(selectedNodes).toBe(totalNodes)\n})\n\ntest(\"다중 선택된 노드 Delete로 동시 삭제\", async ({ page }) => {\n\tawait page.goto(\"http://localhost:3000\")\n\t\n\t// 여러 노드 선택\n\tawait page.keyboard.press(\"Meta+a\")\n\tconst initialCount = await page.locator('[data-node-id]').count()\n\t\n\t// Delete 키로 삭제\n\tawait page.keyboard.press(\"Delete\")\n\t\n\t// 노드들이 삭제되었는지 확인\n\tconst afterCount = await page.locator('[data-node-id]').count()\n\texpect(afterCount).toBeLessThan(initialCount)\n})\n```\n\n**3. 수동 테스트 체크리스트**\n- [ ] Shift+클릭으로 여러 노드를 순차적으로 선택할 수 있는가?\n- [ ] Shift+클릭으로 이미 선택된 노드를 선택 해제할 수 있는가?\n- [ ] 빈 캔버스를 드래그하면 파란색 점선 Marquee 박스가 표시되는가?\n- [ ] Marquee 드래그 중 실시간으로 교차하는 노드들이 선택되는가?\n- [ ] Marquee 드래그 종료 시 박스가 사라지고 선택은 유지되는가?\n- [ ] Shift+Marquee로 기존 선택을 유지하며 추가 선택할 수 있는가?\n- [ ] Ctrl/Cmd+A로 현재 페이지의 모든 노드가 선택되는가?\n- [ ] 다중 선택된 노드를 드래그하면 모두 함께 이동하는가?\n- [ ] locked 노드는 다중 이동 시 이동되지 않는가?\n- [ ] Delete/Backspace로 다중 선택된 노드들이 모두 삭제되는가?\n- [ ] 방향키로 다중 선택된 노드들이 함께 이동하는가?\n- [ ] Escape로 다중 선택이 모두 해제되는가?",
				"status": "pending",
				"dependencies": ["11"],
				"priority": "medium",
				"subtasks": []
			},
			{
				"id": "17",
				"title": "노드 그룹화 기능 구현",
				"description": "선택된 여러 노드를 div wrapper로 그룹화하고, 그룹 해제 시 wrapper를 제거하여 자식 노드들을 상위로 이동시킵니다. Ctrl/Cmd+G로 그룹화, Ctrl/Cmd+Shift+G로 그룹 해제하며, 레이어 패널에서 그룹 접기/펼치기가 가능합니다.",
				"details": "**현재 상태 분석:**\n- 다중 선택 시스템 구현됨 (`selection: string[]`, `editor.ts:191`)\n- `findParentInPage`로 부모 노드 탐색 가능 (`editor.ts:88-110`)\n- `addNode`로 노드 추가 지원 (`editor.ts:211-247`)\n- `removeNode`로 노드 삭제 지원 (`editor.ts:249-262`)\n- 레이어 패널 계층 구조 렌더링 완료 (`LayersPanel.tsx:115-124`)\n- 접기/펼치기 상태 관리 중 (`collapsedIds`, `LayersPanel.tsx:186`)\n- Command 시스템 준비 완료 (`CommandRegistry`, `commands/node.ts`)\n- 기본 키바인딩 설정 존재 (`keybindings/defaults.ts`)\n\n**구현 단계:**\n\n**1. EditorStore에 그룹화 메서드 추가**\n\n`packages/editor-shell/src/store/editor.ts`에 다음 메서드들 추가:\n\n```typescript\n/**\n * 선택된 노드들을 그룹(div wrapper)으로 묶기\n */\ngroupNodes(nodeIds: string[]) {\n\tconst state = get()\n\tconst page = getCurrentPage(state.document, state.currentPageId)\n\tif (!page || nodeIds.length === 0) return\n\n\t// 모든 노드가 같은 부모를 가지는지 확인\n\tconst parents = nodeIds.map(id => findParentInPage(page, id))\n\tconst firstParent = parents[0]\n\tif (!firstParent || parents.some(p => p?.id !== firstParent.id)) {\n\t\tconsole.warn(\"그룹화할 노드들이 같은 부모를 가져야 합니다\")\n\t\treturn\n\t}\n\n\t// 노드들 찾기\n\tconst nodes = nodeIds.map(id => findNodeInPage(page, id)).filter(Boolean) as SceneNode[]\n\tif (nodes.length !== nodeIds.length) return\n\n\t// 그룹 노드 생성 (div wrapper)\n\tconst groupId = `group-${Date.now()}-${Math.random().toString(36).slice(2, 7)}`\n\tconst groupNode: ElementNode = {\n\t\tid: groupId,\n\t\ttype: \"element\",\n\t\ttag: \"div\",\n\t\tstyle: {\n\t\t\tposition: \"absolute\",\n\t\t\t// 모든 자식 노드를 포함하는 최소 바운딩 박스 계산\n\t\t\tleft: Math.min(...nodes.map(n => (n.style?.left as number) ?? 0)),\n\t\t\ttop: Math.min(...nodes.map(n => (n.style?.top as number) ?? 0)),\n\t\t\twidth: Math.max(...nodes.map(n => ((n.style?.left as number) ?? 0) + ((n.style?.width as number) ?? 100))) -\n\t\t\t\tMath.min(...nodes.map(n => (n.style?.left as number) ?? 0)),\n\t\t\theight: Math.max(...nodes.map(n => ((n.style?.top as number) ?? 0) + ((n.style?.height as number) ?? 100))) -\n\t\t\t\tMath.min(...nodes.map(n => (n.style?.top as number) ?? 0)),\n\t\t},\n\t\tchildren: [],\n\t}\n\n\t// 자식 노드들의 위치를 그룹 기준으로 상대 위치로 변경\n\tconst groupLeft = groupNode.style?.left as number\n\tconst groupTop = groupNode.style?.top as number\n\tconst adjustedChildren = nodes.map(node => ({\n\t\t...node,\n\t\tstyle: {\n\t\t\t...node.style,\n\t\t\tleft: ((node.style?.left as number) ?? 0) - groupLeft,\n\t\t\ttop: ((node.style?.top as number) ?? 0) - groupTop,\n\t\t},\n\t}))\n\tgroupNode.children = adjustedChildren\n\n\t// 기존 노드들 삭제 (역순으로 삭제하여 인덱스 꼬임 방지)\n\tconst sortedIds = [...nodeIds].sort((a, b) => {\n\t\tconst parentChildren = \"children\" in firstParent ? firstParent.children : []\n\t\tif (!Array.isArray(parentChildren)) return 0\n\t\treturn parentChildren.findIndex(c => c.id === b) - parentChildren.findIndex(c => c.id === a)\n\t})\n\t\n\t// 첫 번째 노드의 인덱스 저장 (그룹이 삽입될 위치)\n\tconst parentChildren = \"children\" in firstParent ? firstParent.children : []\n\tconst firstNodeIndex = Array.isArray(parentChildren) \n\t\t? parentChildren.findIndex(c => c.id === nodeIds[0])\n\t\t: -1\n\n\tfor (const id of sortedIds) {\n\t\tstate.removeNode(id)\n\t}\n\n\t// 그룹 노드 추가\n\tstate.addNode(firstParent.id, groupNode, firstNodeIndex !== -1 ? firstNodeIndex : undefined)\n\t\n\t// 그룹 노드 선택\n\tstate.setSelection([groupId])\n},\n\n/**\n * 그룹 해제 (wrapper 제거, 자식 노드들 상위로 이동)\n */\nungroupNodes(groupId: string) {\n\tconst state = get()\n\tconst page = getCurrentPage(state.document, state.currentPageId)\n\tif (!page) return\n\n\tconst groupNode = findNodeInPage(page, groupId)\n\tif (!groupNode || groupNode.type !== \"element\" || !Array.isArray(groupNode.children)) {\n\t\tconsole.warn(\"그룹 노드가 아니거나 자식이 없습니다\")\n\t\treturn\n\t}\n\n\tconst parent = findParentInPage(page, groupId)\n\tif (!parent) return\n\n\t// 그룹의 절대 위치\n\tconst groupLeft = (groupNode.style?.left as number) ?? 0\n\tconst groupTop = (groupNode.style?.top as number) ?? 0\n\n\t// 그룹의 인덱스 찾기\n\tconst parentChildren = \"children\" in parent ? parent.children : []\n\tconst groupIndex = Array.isArray(parentChildren)\n\t\t? parentChildren.findIndex(c => c.id === groupId)\n\t\t: -1\n\n\t// 자식 노드들의 위치를 절대 위치로 변경\n\tconst adjustedChildren = groupNode.children.map(child => ({\n\t\t...child,\n\t\tstyle: {\n\t\t\t...child.style,\n\t\t\tleft: ((child.style?.left as number) ?? 0) + groupLeft,\n\t\t\ttop: ((child.style?.top as number) ?? 0) + groupTop,\n\t\t},\n\t}))\n\n\t// 그룹 노드 삭제\n\tstate.removeNode(groupId)\n\n\t// 자식 노드들을 상위로 이동 (역순으로 삽입하여 순서 유지)\n\tconst insertIndex = groupIndex !== -1 ? groupIndex : undefined\n\tfor (let i = adjustedChildren.length - 1; i >= 0; i--) {\n\t\tstate.addNode(parent.id, adjustedChildren[i], insertIndex)\n\t}\n\n\t// 이동된 노드들 선택\n\tstate.setSelection(adjustedChildren.map(c => c.id))\n},\n```\n\n**2. 그룹화 Command 등록**\n\n`packages/editor-shell/src/commands/node.ts`에 추가:\n\n```typescript\ncommandRegistry.register(\"node:group\", () => {\n\tconst selection = useEditorStore.getState().selection\n\tif (selection.length < 2) {\n\t\tconsole.warn(\"그룹화하려면 2개 이상의 노드를 선택해야 합니다\")\n\t\treturn\n\t}\n\tuseEditorStore.getState().groupNodes(selection)\n})\n\ncommandRegistry.register(\"node:ungroup\", () => {\n\tconst selection = useEditorStore.getState().selection\n\tif (selection.length !== 1) {\n\t\tconsole.warn(\"그룹 해제하려면 1개의 그룹 노드를 선택해야 합니다\")\n\t\treturn\n\t}\n\tuseEditorStore.getState().ungroupNodes(selection[0])\n})\n```\n\n**3. 키바인딩 등록**\n\n`packages/editor-shell/src/keybindings/defaults.ts`에 추가:\n\n```typescript\n// Node 섹션에 추가\n{ key: \"g\", modifiers: { meta: true }, command: \"node:group\", when: \"hasSelection\" },\n{ key: \"g\", modifiers: { meta: true, shift: true }, command: \"node:ungroup\", when: \"hasSelection\" },\n```\n\n**4. EditorStore 타입 확장**\n\n`packages/editor-core/src/types/editor.ts`의 `EditorStore` 인터페이스에 추가:\n\n```typescript\nexport interface EditorStore {\n\t// ... 기존 필드들\n\t\n\t/**\n\t * 선택된 노드들을 그룹(div wrapper)으로 묶기\n\t */\n\tgroupNodes: (nodeIds: string[]) => void\n\t\n\t/**\n\t * 그룹 해제 (wrapper 제거, 자식 노드들 상위로 이동)\n\t */\n\tungroupNodes: (groupId: string) => void\n}\n```\n\n**5. 레이어 패널 그룹 표시 개선 (선택사항)**\n\n그룹 노드를 시각적으로 구분하기 위해 `LayersPanel.tsx`의 `layer-name` 표시 부분 개선:\n\n```typescript\n<span className=\"layer-name\" {...attributes} {...listeners}>\n\t{node.type === \"element\" \n\t\t? node.tag === \"div\" && Array.isArray(node.children) && node.children.length > 0\n\t\t\t? `${node.tag} (그룹)`\n\t\t\t: node.tag\n\t\t: \"Instance\"}\n</span>\n```\n\n**주의사항:**\n- 그룹화할 노드들이 같은 부모를 가져야 함\n- 그룹 해제는 ElementNode이며 children이 배열인 경우만 가능\n- 노드 위치 계산 시 `style?.left`, `style?.top`이 없을 경우 0으로 처리\n- 그룹 노드도 일반 노드처럼 `NodeWrapper`에서 이동/리사이즈 가능 (별도 작업 불필요)\n- 이미 구현된 접기/펼치기 기능이 그룹 노드에도 자동 적용됨",
				"testStrategy": "**테스트 전략:**\n\n**1. 단위 테스트 (`vitest/store/grouping.test.ts`)**\n```typescript\ndescribe(\"노드 그룹화 기능\", () => {\n\tbeforeEach(() => {\n\t\tuseEditorStore.setState({\n\t\t\tdocument: createTestDocument(),\n\t\t\tselection: [],\n\t\t})\n\t})\n\n\tit(\"여러 노드를 div wrapper로 그룹화\", () => {\n\t\tconst { groupNodes, findNode } = useEditorStore.getState()\n\t\tconst node1 = createTestNode({ id: \"node-1\", left: 100, top: 100 })\n\t\tconst node2 = createTestNode({ id: \"node-2\", left: 200, top: 150 })\n\t\t\n\t\t// 노드 추가 및 그룹화\n\t\tgroupNodes([\"node-1\", \"node-2\"])\n\t\t\n\t\t// 그룹 노드 생성 확인\n\t\tconst groups = getCurrentPage().children.filter(n => \n\t\t\tn.type === \"element\" && n.tag === \"div\" && n.id.startsWith(\"group-\")\n\t\t)\n\t\texpect(groups).toHaveLength(1)\n\t\t\n\t\tconst group = groups[0] as ElementNode\n\t\texpect(group.children).toHaveLength(2)\n\t\texpect(group.style?.left).toBe(100)\n\t\texpect(group.style?.top).toBe(100)\n\t})\n\n\tit(\"그룹화 시 자식 노드 위치가 상대 좌표로 변환\", () => {\n\t\tconst { groupNodes, findNode } = useEditorStore.getState()\n\t\tgroupNodes([\"node-1\", \"node-2\"])\n\t\t\n\t\tconst group = findNode(\"group-*\") // 패턴 매칭\n\t\tconst child1 = (group as ElementNode).children[0]\n\t\tconst child2 = (group as ElementNode).children[1]\n\t\t\n\t\texpect(child1.style?.left).toBe(0) // 100 - 100\n\t\texpect(child1.style?.top).toBe(0) // 100 - 100\n\t\texpect(child2.style?.left).toBe(100) // 200 - 100\n\t\texpect(child2.style?.top).toBe(50) // 150 - 100\n\t})\n\n\tit(\"그룹 해제 시 자식 노드들이 절대 좌표로 복원\", () => {\n\t\tconst { groupNodes, ungroupNodes, findNode } = useEditorStore.getState()\n\t\t\n\t\tgroupNodes([\"node-1\", \"node-2\"])\n\t\tconst groupId = getCurrentPage().children.find(n => n.id.startsWith(\"group-\"))!.id\n\t\t\n\t\tungroupNodes(groupId)\n\t\t\n\t\t// 그룹 노드 제거 확인\n\t\texpect(findNode(groupId)).toBeNull()\n\t\t\n\t\t// 자식 노드들이 상위로 이동 및 절대 좌표 복원 확인\n\t\tconst node1 = findNode(\"node-1\")\n\t\tconst node2 = findNode(\"node-2\")\n\t\texpect(node1?.style?.left).toBe(100)\n\t\texpect(node1?.style?.top).toBe(100)\n\t\texpect(node2?.style?.left).toBe(200)\n\t\texpect(node2?.style?.top).toBe(150)\n\t})\n\n\tit(\"같은 부모를 가지지 않는 노드는 그룹화 불가\", () => {\n\t\tconst { groupNodes } = useEditorStore.getState()\n\t\tconst consoleSpy = vi.spyOn(console, \"warn\").mockImplementation()\n\t\t\n\t\t// node-1은 페이지 직속, node-3은 node-1의 자식\n\t\tgroupNodes([\"node-1\", \"node-3\"])\n\t\t\n\t\texpect(consoleSpy).toHaveBeenCalledWith(\n\t\t\texpect.stringContaining(\"같은 부모\")\n\t\t)\n\t})\n\n\tit(\"2개 미만 노드 선택 시 그룹화 경고\", () => {\n\t\tconst consoleSpy = vi.spyOn(console, \"warn\").mockImplementation()\n\t\tcommandRegistry.execute(\"node:group\")\n\t\t\n\t\texpect(consoleSpy).toHaveBeenCalledWith(\n\t\t\texpect.stringContaining(\"2개 이상\")\n\t\t)\n\t})\n})\n```\n\n**2. 통합 테스트 (Playwright)**\n```typescript\ntest(\"Ctrl+G로 노드 그룹화\", async ({ page }) => {\n\t// 여러 노드 선택\n\tawait page.click('[data-node-id=\"node-1\"]')\n\tawait page.keyboard.down(\"Shift\")\n\tawait page.click('[data-node-id=\"node-2\"]')\n\tawait page.keyboard.up(\"Shift\")\n\t\n\t// Ctrl+G 실행 (Mac은 Meta)\n\tawait page.keyboard.press(isMac ? \"Meta+G\" : \"Control+G\")\n\t\n\t// 그룹 노드 생성 확인\n\tconst groupNode = page.locator('[data-node-id^=\"group-\"]')\n\tawait expect(groupNode).toBeVisible()\n\t\n\t// 레이어 패널에서 그룹 표시 확인\n\tconst layerItem = page.locator('.layer-name:has-text(\"div (그룹)\")')\n\tawait expect(layerItem).toBeVisible()\n})\n\ntest(\"Ctrl+Shift+G로 그룹 해제\", async ({ page }) => {\n\t// 그룹 노드 선택\n\tawait page.click('[data-node-id^=\"group-\"]')\n\t\n\t// Ctrl+Shift+G 실행\n\tawait page.keyboard.press(isMac ? \"Meta+Shift+G\" : \"Control+Shift+G\")\n\t\n\t// 그룹 노드 제거 확인\n\tconst groupNode = page.locator('[data-node-id^=\"group-\"]')\n\tawait expect(groupNode).not.toBeVisible()\n\t\n\t// 자식 노드들이 상위로 이동 확인\n\tawait expect(page.locator('[data-node-id=\"node-1\"]')).toBeVisible()\n\tawait expect(page.locator('[data-node-id=\"node-2\"]')).toBeVisible()\n})\n\ntest(\"그룹 노드 이동 및 리사이즈\", async ({ page }) => {\n\t// 그룹 생성 후 선택\n\tconst groupNode = page.locator('[data-node-id^=\"group-\"]')\n\t\n\t// 드래그로 이동\n\tawait groupNode.dragTo(groupNode, { \n\t\ttargetPosition: { x: 150, y: 150 }\n\t})\n\t\n\t// 위치 변경 확인\n\tconst box = await groupNode.boundingBox()\n\texpect(box?.x).toBeCloseTo(150, 1)\n\texpect(box?.y).toBeCloseTo(150, 1)\n\t\n\t// 리사이즈 핸들로 크기 조절\n\tconst resizeHandle = groupNode.locator('.react-resizable-handle')\n\tawait resizeHandle.dragTo(resizeHandle, {\n\t\ttargetPosition: { x: 50, y: 50 }\n\t})\n\t\n\t// 크기 변경 확인\n\tconst newBox = await groupNode.boundingBox()\n\texpect(newBox?.width).toBeGreaterThan(box?.width ?? 0)\n})\n\ntest(\"레이어 패널에서 그룹 접기/펼치기\", async ({ page }) => {\n\t// 그룹 노드의 접기 버튼 클릭\n\tconst collapseBtn = page.locator('.layer-row:has-text(\"div (그룹)\") .layer-collapse-btn')\n\tawait collapseBtn.click()\n\t\n\t// 자식 노드 숨김 확인\n\tawait expect(page.locator('.layer-children')).not.toBeVisible()\n\t\n\t// 다시 펼치기\n\tawait collapseBtn.click()\n\tawait expect(page.locator('.layer-children')).toBeVisible()\n})\n```\n\n**3. 수동 테스트 체크리스트**\n- [ ] 2개 이상 노드 선택 → Ctrl/Cmd+G → 그룹 생성 확인\n- [ ] 그룹 선택 → Ctrl/Cmd+Shift+G → 그룹 해제 확인\n- [ ] 그룹 노드 드래그로 이동 가능 확인\n- [ ] 그룹 노드 리사이즈 핸들로 크기 조절 가능 확인\n- [ ] 레이어 패널에서 그룹 접기/펼치기 버튼 동작 확인\n- [ ] 그룹 내부 노드 선택 및 편집 가능 확인\n- [ ] 중첩 그룹 (그룹 안에 그룹) 생성 및 해제 확인\n- [ ] Undo/Redo로 그룹화 작업 취소/재실행 확인",
				"status": "pending",
				"dependencies": ["16"],
				"priority": "medium",
				"subtasks": []
			},
			{
				"id": "18",
				"title": "노드 정렬 및 균등 배치 기능 구현",
				"description": "다중 선택된 노드들에 대해 좌/우/상/하/가로중앙/세로중앙 정렬과 가로/세로 균등 배치(distribute) 기능을 구현하고, 툴바 또는 우클릭 메뉴를 통해 접근 가능하게 합니다.",
				"details": "**현재 상태 분석:**\n- 다중 선택 시스템 구현됨 (`selection: string[]`, `editor.ts:191`)\n- `findNodeInPage`로 노드 조회 가능 (`editor.ts:17-23`)\n- `updateNode`로 노드 스타일 업데이트 지원 (`editor.ts:197-209`)\n- `moveNode`로 노드 위치 이동 지원 (`editor.ts:264-279`)\n- 노드는 `position: absolute`, `left`, `top` 스타일로 위치 관리 (`editor.ts:274-276`)\n- `NodeWrapper`가 노드의 크기/위치 렌더링 담당 (`NodeWrapper.tsx:21-29`)\n- Command 시스템 준비 완료 (`CommandRegistry`, `commands/node.ts`)\n- 툴바 컴포넌트 존재 (`Toolbar.tsx`)\n\n**구현 단계:**\n\n**1. 노드 바운딩 박스 계산 유틸리티 추가**\n\n`packages/editor-shell/src/store/editor.ts`에 헬퍼 함수 추가:\n```typescript\n/**\n * 노드의 바운딩 박스 계산 (position, width, height 기반)\n */\nfunction getNodeBounds(node: SceneNode): { left: number; top: number; right: number; bottom: number; width: number; height: number } | null {\n\tconst style = node.style ?? {}\n\tconst left = (style.left as number) ?? 0\n\tconst top = (style.top as number) ?? 0\n\tconst width = (style.width as number) ?? 0\n\tconst height = (style.height as number) ?? 0\n\t\n\treturn {\n\t\tleft,\n\t\ttop,\n\t\tright: left + width,\n\t\tbottom: top + height,\n\t\twidth,\n\t\theight,\n\t}\n}\n\n/**\n * 여러 노드의 전체 바운딩 박스 계산\n */\nfunction getGroupBounds(nodes: SceneNode[]): { minLeft: number; minTop: number; maxRight: number; maxBottom: number } | null {\n\tif (nodes.length === 0) return null\n\t\n\tlet minLeft = Infinity\n\tlet minTop = Infinity\n\tlet maxRight = -Infinity\n\tlet maxBottom = -Infinity\n\t\n\tfor (const node of nodes) {\n\t\tconst bounds = getNodeBounds(node)\n\t\tif (!bounds) continue\n\t\t\n\t\tminLeft = Math.min(minLeft, bounds.left)\n\t\tminTop = Math.min(minTop, bounds.top)\n\t\tmaxRight = Math.max(maxRight, bounds.right)\n\t\tmaxBottom = Math.max(maxBottom, bounds.bottom)\n\t}\n\t\n\treturn { minLeft, minTop, maxRight, maxBottom }\n}\n```\n\n**2. EditorStore에 정렬/배치 메서드 추가**\n\n`packages/editor-shell/src/store/editor.ts`의 `EditorStore` 인터페이스와 구현부에 추가:\n\n```typescript\n// packages/editor-core/src/types/editor.ts - EditorStore 인터페이스에 추가\nexport type AlignType = \"left\" | \"right\" | \"top\" | \"bottom\" | \"center-horizontal\" | \"center-vertical\"\nexport type DistributeType = \"horizontal\" | \"vertical\"\n\nexport interface EditorStore {\n\t// ... 기존 메서드들\n\talignNodes(ids: string[], alignType: AlignType): void\n\tdistributeNodes(ids: string[], distributeType: DistributeType): void\n}\n```\n\n`packages/editor-shell/src/store/editor.ts`의 `create` 함수 내부에 구현:\n\n```typescript\nalignNodes(ids: string[], alignType: AlignType) {\n\tconst state = get()\n\tconst page = getCurrentPage(state.document, state.currentPageId)\n\tif (!page || ids.length < 2) return\n\t\n\tconst nodes = ids.map(id => findNodeInPage(page, id)).filter(Boolean) as SceneNode[]\n\tif (nodes.length < 2) return\n\t\n\tconst groupBounds = getGroupBounds(nodes)\n\tif (!groupBounds) return\n\t\n\tnodes.forEach(node => {\n\t\tconst bounds = getNodeBounds(node)\n\t\tif (!bounds) return\n\t\t\n\t\tlet newLeft = bounds.left\n\t\tlet newTop = bounds.top\n\t\t\n\t\tswitch (alignType) {\n\t\t\tcase \"left\":\n\t\t\t\tnewLeft = groupBounds.minLeft\n\t\t\t\tbreak\n\t\t\tcase \"right\":\n\t\t\t\tnewLeft = groupBounds.maxRight - bounds.width\n\t\t\t\tbreak\n\t\t\tcase \"top\":\n\t\t\t\tnewTop = groupBounds.minTop\n\t\t\t\tbreak\n\t\t\tcase \"bottom\":\n\t\t\t\tnewTop = groupBounds.maxBottom - bounds.height\n\t\t\t\tbreak\n\t\t\tcase \"center-horizontal\":\n\t\t\t\tnewLeft = (groupBounds.minLeft + groupBounds.maxRight) / 2 - bounds.width / 2\n\t\t\t\tbreak\n\t\t\tcase \"center-vertical\":\n\t\t\t\tnewTop = (groupBounds.minTop + groupBounds.maxBottom) / 2 - bounds.height / 2\n\t\t\t\tbreak\n\t\t}\n\t\t\n\t\tstate.updateNode(node.id, {\n\t\t\tstyle: {\n\t\t\t\t...node.style,\n\t\t\t\tposition: \"absolute\",\n\t\t\t\tleft: newLeft,\n\t\t\t\ttop: newTop,\n\t\t\t},\n\t\t})\n\t})\n},\n\ndistributeNodes(ids: string[], distributeType: DistributeType) {\n\tconst state = get()\n\tconst page = getCurrentPage(state.document, state.currentPageId)\n\tif (!page || ids.length < 3) return // 균등 배치는 최소 3개 필요\n\t\n\tconst nodes = ids.map(id => findNodeInPage(page, id)).filter(Boolean) as SceneNode[]\n\tif (nodes.length < 3) return\n\t\n\t// 정렬 기준에 따라 노드 정렬\n\tconst sortedNodes = [...nodes].sort((a, b) => {\n\t\tconst boundsA = getNodeBounds(a)\n\t\tconst boundsB = getNodeBounds(b)\n\t\tif (!boundsA || !boundsB) return 0\n\t\t\n\t\tif (distributeType === \"horizontal\") {\n\t\t\treturn boundsA.left - boundsB.left\n\t\t} else {\n\t\t\treturn boundsA.top - boundsB.top\n\t\t}\n\t})\n\t\n\tconst firstBounds = getNodeBounds(sortedNodes[0])\n\tconst lastBounds = getNodeBounds(sortedNodes[sortedNodes.length - 1])\n\tif (!firstBounds || !lastBounds) return\n\t\n\tif (distributeType === \"horizontal\") {\n\t\t// 전체 사용 가능한 공간 계산\n\t\tconst totalSpace = lastBounds.left - (firstBounds.left + firstBounds.width)\n\t\t// 노드들의 총 너비 계산 (첫번째와 마지막 제외)\n\t\tconst middleNodesWidth = sortedNodes.slice(1, -1).reduce((sum, node) => {\n\t\t\tconst bounds = getNodeBounds(node)\n\t\t\treturn sum + (bounds?.width ?? 0)\n\t\t}, 0)\n\t\t// 간격 계산\n\t\tconst gap = (totalSpace - middleNodesWidth) / (sortedNodes.length - 1)\n\t\t\n\t\tlet currentLeft = firstBounds.left + firstBounds.width + gap\n\t\t\n\t\t// 중간 노드들 재배치 (첫번째와 마지막은 고정)\n\t\tfor (let i = 1; i < sortedNodes.length - 1; i++) {\n\t\t\tconst node = sortedNodes[i]\n\t\t\tconst bounds = getNodeBounds(node)\n\t\t\tif (!bounds) continue\n\t\t\t\n\t\t\tstate.updateNode(node.id, {\n\t\t\t\tstyle: {\n\t\t\t\t\t...node.style,\n\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\tleft: currentLeft,\n\t\t\t\t},\n\t\t\t})\n\t\t\t\n\t\t\tcurrentLeft += bounds.width + gap\n\t\t}\n\t} else {\n\t\t// 세로 균등 배치\n\t\tconst totalSpace = lastBounds.top - (firstBounds.top + firstBounds.height)\n\t\tconst middleNodesHeight = sortedNodes.slice(1, -1).reduce((sum, node) => {\n\t\t\tconst bounds = getNodeBounds(node)\n\t\t\treturn sum + (bounds?.height ?? 0)\n\t\t}, 0)\n\t\tconst gap = (totalSpace - middleNodesHeight) / (sortedNodes.length - 1)\n\t\t\n\t\tlet currentTop = firstBounds.top + firstBounds.height + gap\n\t\t\n\t\tfor (let i = 1; i < sortedNodes.length - 1; i++) {\n\t\t\tconst node = sortedNodes[i]\n\t\t\tconst bounds = getNodeBounds(node)\n\t\t\tif (!bounds) continue\n\t\t\t\n\t\t\tstate.updateNode(node.id, {\n\t\t\t\tstyle: {\n\t\t\t\t\t...node.style,\n\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\ttop: currentTop,\n\t\t\t\t},\n\t\t\t})\n\t\t\t\n\t\t\tcurrentTop += bounds.height + gap\n\t\t}\n\t}\n},\n```\n\n**3. Command 등록**\n\n`packages/editor-shell/src/commands/node.ts`에 정렬/배치 커맨드 추가:\n\n```typescript\nexport function registerNodeCommands(): void {\n\t// ... 기존 커맨드들\n\t\n\t// 정렬 커맨드\n\tcommandRegistry.register(\"node:align-left\", () => {\n\t\tconst { selection, alignNodes } = useEditorStore.getState()\n\t\tif (selection.length >= 2) alignNodes(selection, \"left\")\n\t})\n\t\n\tcommandRegistry.register(\"node:align-right\", () => {\n\t\tconst { selection, alignNodes } = useEditorStore.getState()\n\t\tif (selection.length >= 2) alignNodes(selection, \"right\")\n\t})\n\t\n\tcommandRegistry.register(\"node:align-top\", () => {\n\t\tconst { selection, alignNodes } = useEditorStore.getState()\n\t\tif (selection.length >= 2) alignNodes(selection, \"top\")\n\t})\n\t\n\tcommandRegistry.register(\"node:align-bottom\", () => {\n\t\tconst { selection, alignNodes } = useEditorStore.getState()\n\t\tif (selection.length >= 2) alignNodes(selection, \"bottom\")\n\t})\n\t\n\tcommandRegistry.register(\"node:align-center-horizontal\", () => {\n\t\tconst { selection, alignNodes } = useEditorStore.getState()\n\t\tif (selection.length >= 2) alignNodes(selection, \"center-horizontal\")\n\t})\n\t\n\tcommandRegistry.register(\"node:align-center-vertical\", () => {\n\t\tconst { selection, alignNodes } = useEditorStore.getState()\n\t\tif (selection.length >= 2) alignNodes(selection, \"center-vertical\")\n\t})\n\t\n\t// 균등 배치 커맨드\n\tcommandRegistry.register(\"node:distribute-horizontal\", () => {\n\t\tconst { selection, distributeNodes } = useEditorStore.getState()\n\t\tif (selection.length >= 3) distributeNodes(selection, \"horizontal\")\n\t})\n\t\n\tcommandRegistry.register(\"node:distribute-vertical\", () => {\n\t\tconst { selection, distributeNodes } = useEditorStore.getState()\n\t\tif (selection.length >= 3) distributeNodes(selection, \"vertical\")\n\t})\n}\n```\n\n**4. 툴바 UI 추가**\n\n`packages/editor-shell/src/components/Toolbar.tsx`에 정렬 버튼 추가:\n\n```typescript\nimport { commandRegistry } from \"../commands/CommandRegistry\"\n\nexport function Toolbar() {\n\t// ... 기존 코드\n\t\n\tconst hasMultiSelection = selection.length >= 2\n\tconst canDistribute = selection.length >= 3\n\t\n\treturn (\n\t\t<div className=\"toolbar\">\n\t\t\t<div className=\"toolbar-left\">\n\t\t\t\t{/* ... 기존 버튼들 ... */}\n\t\t\t\t\n\t\t\t\t{hasMultiSelection && (\n\t\t\t\t\t<>\n\t\t\t\t\t\t<div className=\"toolbar-separator\" />\n\t\t\t\t\t\t<div className=\"toolbar-group\" title=\"Align\">\n\t\t\t\t\t\t\t<button \n\t\t\t\t\t\t\t\tclassName=\"toolbar-button toolbar-button-small\" \n\t\t\t\t\t\t\t\tonClick={() => commandRegistry.execute(\"node:align-left\")}\n\t\t\t\t\t\t\t\ttitle=\"Align Left\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t⫷\n\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t<button \n\t\t\t\t\t\t\t\tclassName=\"toolbar-button toolbar-button-small\" \n\t\t\t\t\t\t\t\tonClick={() => commandRegistry.execute(\"node:align-center-horizontal\")}\n\t\t\t\t\t\t\t\ttitle=\"Align Center Horizontal\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t⫼\n\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t<button \n\t\t\t\t\t\t\t\tclassName=\"toolbar-button toolbar-button-small\" \n\t\t\t\t\t\t\t\tonClick={() => commandRegistry.execute(\"node:align-right\")}\n\t\t\t\t\t\t\t\ttitle=\"Align Right\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t⫸\n\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t<button \n\t\t\t\t\t\t\t\tclassName=\"toolbar-button toolbar-button-small\" \n\t\t\t\t\t\t\t\tonClick={() => commandRegistry.execute(\"node:align-top\")}\n\t\t\t\t\t\t\t\ttitle=\"Align Top\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t⫴\n\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t<button \n\t\t\t\t\t\t\t\tclassName=\"toolbar-button toolbar-button-small\" \n\t\t\t\t\t\t\t\tonClick={() => commandRegistry.execute(\"node:align-center-vertical\")}\n\t\t\t\t\t\t\t\ttitle=\"Align Center Vertical\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t⫽\n\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t<button \n\t\t\t\t\t\t\t\tclassName=\"toolbar-button toolbar-button-small\" \n\t\t\t\t\t\t\t\tonClick={() => commandRegistry.execute(\"node:align-bottom\")}\n\t\t\t\t\t\t\t\ttitle=\"Align Bottom\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t⫵\n\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</>\n\t\t\t\t)}\n\t\t\t\t\n\t\t\t\t{canDistribute && (\n\t\t\t\t\t<>\n\t\t\t\t\t\t<div className=\"toolbar-separator\" />\n\t\t\t\t\t\t<div className=\"toolbar-group\" title=\"Distribute\">\n\t\t\t\t\t\t\t<button \n\t\t\t\t\t\t\t\tclassName=\"toolbar-button toolbar-button-small\" \n\t\t\t\t\t\t\t\tonClick={() => commandRegistry.execute(\"node:distribute-horizontal\")}\n\t\t\t\t\t\t\t\ttitle=\"Distribute Horizontal\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t⟷\n\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t<button \n\t\t\t\t\t\t\t\tclassName=\"toolbar-button toolbar-button-small\" \n\t\t\t\t\t\t\t\tonClick={() => commandRegistry.execute(\"node:distribute-vertical\")}\n\t\t\t\t\t\t\t\ttitle=\"Distribute Vertical\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t⟱\n\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</>\n\t\t\t\t)}\n\t\t\t</div>\n\t\t\t{/* ... 나머지 코드 ... */}\n\t\t</div>\n\t)\n}\n```\n\n**5. 툴바 스타일 추가**\n\n`packages/editor-shell/src/components/Toolbar.css`에 추가:\n\n```css\n.toolbar-group {\n\tdisplay: flex;\n\tgap: 2px;\n\talign-items: center;\n}\n\n.toolbar-button-small {\n\tpadding: 4px 6px;\n\tmin-width: 28px;\n\tfont-size: 14px;\n}\n```\n\n**6. 키보드 단축키 추가 (Optional)**\n\n`packages/editor-shell/src/keybindings/defaults.ts`에 단축키 추가:\n\n```typescript\nexport const defaultKeybindings: KeyBinding[] = [\n\t// ... 기존 키바인딩들\n\t\n\t// 정렬 단축키 (Ctrl/Cmd + Shift + Arrow)\n\t{ key: \"arrowleft\", metaKey: true, shiftKey: true, commandId: \"node:align-left\" },\n\t{ key: \"arrowright\", metaKey: true, shiftKey: true, commandId: \"node:align-right\" },\n\t{ key: \"arrowup\", metaKey: true, shiftKey: true, commandId: \"node:align-top\" },\n\t{ key: \"arrowdown\", metaKey: true, shiftKey: true, commandId: \"node:align-bottom\" },\n\t\n\t// 균등 배치 단축키\n\t{ key: \"h\", metaKey: true, altKey: true, commandId: \"node:distribute-horizontal\" },\n\t{ key: \"v\", metaKey: true, altKey: true, commandId: \"node:distribute-vertical\" },\n]\n```\n\n**구현 시 주의사항:**\n- 노드가 `position: absolute`이 아닌 경우 정렬 시 자동으로 설정\n- `width`/`height`가 없는 노드는 정렬/배치에서 제외하거나 기본값 사용\n- History(Undo/Redo)는 `temporal` 미들웨어가 자동 처리\n- 2개 미만 선택 시 정렬 버튼 비활성화, 3개 미만 시 균등 배치 버튼 비활성화\n- 락 걸린 노드도 정렬/배치 가능 (위치만 변경, 락 상태 유지)\n- 정렬/배치 후 선택 상태 유지",
				"testStrategy": "**테스트 전략:**\n\n**1. 단위 테스트 (`vitest/store/alignment.test.ts`)**\n```typescript\ndescribe(\"노드 정렬 기능\", () => {\n\tbeforeEach(() => {\n\t\tuseEditorStore.setState({\n\t\t\tdocument: createTestDocument([\n\t\t\t\tcreateNode(\"node-1\", { left: 0, top: 0, width: 100, height: 100 }),\n\t\t\t\tcreateNode(\"node-2\", { left: 200, top: 50, width: 100, height: 100 }),\n\t\t\t\tcreateNode(\"node-3\", { left: 100, top: 200, width: 100, height: 100 }),\n\t\t\t]),\n\t\t\tselection: [\"node-1\", \"node-2\", \"node-3\"],\n\t\t})\n\t})\n\n\tit(\"alignNodes('left'): 모든 노드가 가장 왼쪽 노드에 정렬\", () => {\n\t\tconst { alignNodes, findNode } = useEditorStore.getState()\n\t\talignNodes([\"node-1\", \"node-2\", \"node-3\"], \"left\")\n\t\t\n\t\texpect(findNode(\"node-1\")?.style?.left).toBe(0)\n\t\texpect(findNode(\"node-2\")?.style?.left).toBe(0)\n\t\texpect(findNode(\"node-3\")?.style?.left).toBe(0)\n\t})\n\n\tit(\"alignNodes('right'): 모든 노드가 가장 오른쪽 노드에 정렬\", () => {\n\t\tconst { alignNodes, findNode } = useEditorStore.getState()\n\t\talignNodes([\"node-1\", \"node-2\", \"node-3\"], \"right\")\n\t\t\n\t\t// node-2의 right: 200 + 100 = 300이 최대\n\t\texpect(findNode(\"node-1\")?.style?.left).toBe(200) // 300 - 100\n\t\texpect(findNode(\"node-2\")?.style?.left).toBe(200)\n\t\texpect(findNode(\"node-3\")?.style?.left).toBe(200)\n\t})\n\n\tit(\"alignNodes('top'): 모든 노드가 가장 위쪽 노드에 정렬\", () => {\n\t\tconst { alignNodes, findNode } = useEditorStore.getState()\n\t\talignNodes([\"node-1\", \"node-2\", \"node-3\"], \"top\")\n\t\t\n\t\texpect(findNode(\"node-1\")?.style?.top).toBe(0)\n\t\texpect(findNode(\"node-2\")?.style?.top).toBe(0)\n\t\texpect(findNode(\"node-3\")?.style?.top).toBe(0)\n\t})\n\n\tit(\"alignNodes('bottom'): 모든 노드가 가장 아래쪽 노드에 정렬\", () => {\n\t\tconst { alignNodes, findNode } = useEditorStore.getState()\n\t\talignNodes([\"node-1\", \"node-2\", \"node-3\"], \"bottom\")\n\t\t\n\t\t// node-3의 bottom: 200 + 100 = 300이 최대\n\t\texpect(findNode(\"node-1\")?.style?.top).toBe(200)\n\t\texpect(findNode(\"node-2\")?.style?.top).toBe(200)\n\t\texpect(findNode(\"node-3\")?.style?.top).toBe(200)\n\t})\n\n\tit(\"alignNodes('center-horizontal'): 가로 중앙 정렬\", () => {\n\t\tconst { alignNodes, findNode } = useEditorStore.getState()\n\t\talignNodes([\"node-1\", \"node-2\", \"node-3\"], \"center-horizontal\")\n\t\t\n\t\t// 전체 범위: left 0 ~ right 300 → 중앙 150\n\t\texpect(findNode(\"node-1\")?.style?.left).toBe(100) // 150 - 50(width/2)\n\t\texpect(findNode(\"node-2\")?.style?.left).toBe(100)\n\t\texpect(findNode(\"node-3\")?.style?.left).toBe(100)\n\t})\n\n\tit(\"alignNodes('center-vertical'): 세로 중앙 정렬\", () => {\n\t\tconst { alignNodes, findNode } = useEditorStore.getState()\n\t\talignNodes([\"node-1\", \"node-2\", \"node-3\"], \"center-vertical\")\n\t\t\n\t\t// 전체 범위: top 0 ~ bottom 300 → 중앙 150\n\t\texpect(findNode(\"node-1\")?.style?.top).toBe(100)\n\t\texpect(findNode(\"node-2\")?.style?.top).toBe(100)\n\t\texpect(findNode(\"node-3\")?.style?.top).toBe(100)\n\t})\n\n\tit(\"2개 미만 선택 시 정렬 안됨\", () => {\n\t\tconst { alignNodes, findNode } = useEditorStore.getState()\n\t\tconst originalLeft = findNode(\"node-1\")?.style?.left\n\t\t\n\t\talignNodes([\"node-1\"], \"left\")\n\t\t\n\t\texpect(findNode(\"node-1\")?.style?.left).toBe(originalLeft)\n\t})\n})\n\ndescribe(\"노드 균등 배치 기능\", () => {\n\tbeforeEach(() => {\n\t\tuseEditorStore.setState({\n\t\t\tdocument: createTestDocument([\n\t\t\t\tcreateNode(\"node-1\", { left: 0, top: 0, width: 50, height: 50 }),\n\t\t\t\tcreateNode(\"node-2\", { left: 100, top: 0, width: 50, height: 50 }),\n\t\t\t\tcreateNode(\"node-3\", { left: 500, top: 0, width: 50, height: 50 }),\n\t\t\t]),\n\t\t\tselection: [\"node-1\", \"node-2\", \"node-3\"],\n\t\t})\n\t})\n\n\tit(\"distributeNodes('horizontal'): 가로 균등 배치\", () => {\n\t\tconst { distributeNodes, findNode } = useEditorStore.getState()\n\t\tdistributeNodes([\"node-1\", \"node-2\", \"node-3\"], \"horizontal\")\n\t\t\n\t\t// node-1: left 0 (고정)\n\t\t// node-3: left 500 (고정)\n\t\t// node-2: 중간에 균등 배치\n\t\t// 전체 공간: 500 - 50 = 450, 중간 노드 너비: 50\n\t\t// 간격: (450 - 50) / 2 = 200\n\t\texpect(findNode(\"node-1\")?.style?.left).toBe(0)\n\t\texpect(findNode(\"node-2\")?.style?.left).toBe(250) // 0 + 50 + 200\n\t\texpect(findNode(\"node-3\")?.style?.left).toBe(500)\n\t})\n\n\tit(\"distributeNodes('vertical'): 세로 균등 배치\", () => {\n\t\tuseEditorStore.setState({\n\t\t\tdocument: createTestDocument([\n\t\t\t\tcreateNode(\"node-1\", { left: 0, top: 0, width: 50, height: 50 }),\n\t\t\t\tcreateNode(\"node-2\", { left: 0, top: 100, width: 50, height: 50 }),\n\t\t\t\tcreateNode(\"node-3\", { left: 0, top: 500, width: 50, height: 50 }),\n\t\t\t]),\n\t\t\tselection: [\"node-1\", \"node-2\", \"node-3\"],\n\t\t})\n\t\t\n\t\tconst { distributeNodes, findNode } = useEditorStore.getState()\n\t\tdistributeNodes([\"node-1\", \"node-2\", \"node-3\"], \"vertical\")\n\t\t\n\t\texpect(findNode(\"node-1\")?.style?.top).toBe(0)\n\t\texpect(findNode(\"node-2\")?.style?.top).toBe(250)\n\t\texpect(findNode(\"node-3\")?.style?.top).toBe(500)\n\t})\n\n\tit(\"3개 미만 선택 시 균등 배치 안됨\", () => {\n\t\tconst { distributeNodes, findNode } = useEditorStore.getState()\n\t\tconst originalLeft = findNode(\"node-2\")?.style?.left\n\t\t\n\t\tdistributeNodes([\"node-1\", \"node-2\"], \"horizontal\")\n\t\t\n\t\texpect(findNode(\"node-2\")?.style?.left).toBe(originalLeft)\n\t})\n})\n```\n\n**2. 통합 테스트 (Canvas 연동 확인)**\n```typescript\ndescribe(\"정렬/배치 Canvas 통합 테스트\", () => {\n\tit(\"정렬 후 Canvas에 올바른 위치로 렌더링\", async () => {\n\t\t// Canvas에 여러 노드 렌더링\n\t\t// 2개 선택 → 좌측 정렬 실행\n\t\t// DOM 요소의 실제 left 값 확인\n\t\tconst node1 = screen.getByTestId(\"node-1\")\n\t\tconst node2 = screen.getByTestId(\"node-2\")\n\t\t\n\t\tuserEvent.click(node1)\n\t\tuserEvent.click(node2, { shiftKey: true })\n\t\t\n\t\tawait commandRegistry.execute(\"node:align-left\")\n\t\t\n\t\texpect(node1.style.left).toBe(node2.style.left)\n\t})\n})\n```\n\n**3. 수동 테스트 체크리스트**\n\n**정렬 기능:**\n- [ ] 3개 이상의 노드 생성 및 무작위 배치\n- [ ] 모두 선택 (Shift+클릭 또는 Cmd/Ctrl+A)\n- [ ] 툴바 좌측 정렬 버튼 클릭 → 모든 노드가 가장 왼쪽에 정렬됨\n- [ ] Undo (Cmd/Ctrl+Z) → 원래 위치로 복구\n- [ ] Redo (Cmd/Ctrl+Y) → 정렬 상태로 복구\n- [ ] 우측/상단/하단/가로중앙/세로중앙 정렬도 동일하게 테스트\n- [ ] 2개 선택 시 정렬 버튼 활성화 확인\n- [ ] 1개만 선택 시 정렬 버튼 비활성화 확인\n\n**균등 배치 기능:**\n- [ ] 5개 노드 생성, 양쪽 끝에 2개, 중간에 3개 무작위 배치\n- [ ] 모두 선택\n- [ ] 툴바 가로 균등 배치 버튼 클릭 → 양 끝은 고정, 중간 노드들이 균등 간격으로 배치\n- [ ] 세로 균등 배치도 동일하게 테스트\n- [ ] 3개 이상 선택 시 균등 배치 버튼 활성화 확인\n- [ ] 2개 이하 선택 시 균등 배치 버튼 비활성화 확인\n\n**키보드 단축키 (Optional):**\n- [ ] Cmd/Ctrl+Shift+←/→/↑/↓로 정렬 동작 확인\n- [ ] Cmd/Ctrl+Alt+H로 가로 균등 배치 확인\n- [ ] Cmd/Ctrl+Alt+V로 세로 균등 배치 확인\n\n**Edge Cases:**\n- [ ] 락 걸린 노드도 정렬/배치 가능 (위치만 변경, 락 유지)\n- [ ] 숨겨진(visible: false) 노드도 정렬/배치 가능\n- [ ] position: relative 노드도 정렬 시 absolute로 변환 확인\n- [ ] width/height 없는 노드 처리 확인\n\n**4. 성능 테스트**\n- [ ] 100개 노드 선택 후 정렬 → 1초 이내 완료\n- [ ] 정렬 중 UI 블로킹 없음 확인",
				"status": "pending",
				"dependencies": ["16"],
				"priority": "low",
				"subtasks": []
			}
		],
		"metadata": {
			"version": "1.0.0",
			"lastModified": "2026-01-31T07:52:52.659Z",
			"taskCount": 18,
			"completedCount": 3,
			"tags": ["master"]
		}
	}
}
