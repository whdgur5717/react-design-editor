---
name: explain
description: 복잡한 코드/개념을 인지부하 없이 단계별로 설명합니다. "이거 설명해줘", "이해하고 싶어", "분석해줘" 같은 요청 시 호출하세요.
---

# Explain — 단계별 심층 설명

복잡한 코드, 아키텍처, 개념을 **한 번에 하나씩**, 기술적 핵심을 놓치지 않으면서 인지부하 없이 설명합니다.

## 핵심 원칙

1. **한 번에 하나만**: 절대 모든 걸 한꺼번에 쏟아붓지 않는다
2. **큰 그림 먼저**: "이게 뭐고 왜 있는가" → "어떻게 동작하는가" → "세부 구현"
3. **기술적 정확성**: 단순화하되 부정확하게 만들지 않는다
4. **사용자 페이스**: 사용자가 "다음"이라고 할 때까지 기다린다

## 워크플로우

### 1. 대상 분석

설명 대상(파일, 함수, 아키텍처, 개념)을 먼저 충분히 읽고 파악한다.

- 코드라면: 파일을 읽고, 관련 타입/import도 확인
- 개념이라면: 코드베이스에서 실제 사용처를 찾아 구체적 예시 확보

### 2. 청크 설계

설명을 **3~6개 청크**로 나눈다. 순서는 반드시:

```
청크 1: 큰 그림 — 이것이 무엇이고 왜 존재하는가 (What & Why)
청크 2: 전체 구조/흐름 — 주요 구성요소와 관계 (Structure)
청크 3~N: 핵심 메커니즘 — 각각의 기술적 동작 원리 (How)
마지막 청크: 요약 — 전체를 한 문단으로 정리
```

각 청크는 **독립적으로 이해 가능**해야 한다. 이전 청크의 내용은 알고 있다고 가정하되, 이후 청크의 내용은 필요하지 않아야 한다.

### 3. 청크별 설명 규칙

각 청크를 설명할 때:

- **제목에 단계 번호**를 붙인다: `## 1단계: 큰 그림 — ...`
- 가능하면 **ASCII 다이어그램, 테이블, 코드 스니펫**을 활용한다
- 비유는 좋지만, 비유에 의존하지 않는다 — 반드시 실제 기술적 설명도 함께
- 한 청크 안에서 3개 이상의 새로운 개념을 도입하지 않는다
- 코드를 인용할 때는 `file_path:line_number` 형태로 위치를 표시한다

### 4. 멈춤과 대기

각 청크 끝에서 **반드시 멈춘다**. 다음 청크로 자동 진행하지 않는다.

청크 끝에 다음을 표시:

```
---
📍 N/M단계 완료. 다음은 "___" 에 대해 설명합니다.
```

사용자가 다음 중 하나를 말하면 다음 청크로 진행:

- "다음", "next", "이해됐어", "understood", "ㅇㅇ", "ok", "계속", "go"

사용자가 질문하면 — 현재 청크 범위 내에서 답변한 뒤, 다시 대기한다.

### 5. 최종 요약

마지막 청크에서 전체를 **한 문단**으로 압축 요약한다. 이 요약만 읽어도 핵심이 파악되어야 한다.

## 설명 포맷 가이드

### 구조/흐름 설명 시

```
A ──이벤트──→ B ──결과──→ C
```

### 분기/판단 설명 시

```
조건 X?
  → YES: 경로 A
  → NO:  경로 B
```

### 여러 항목 비교 시

| 항목 | 역할 | 핵심 |
| ---- | ---- | ---- |
| A    | ...  | ...  |
| B    | ...  | ...  |

### 코드 인용 시

```typescript
// file_path:line_number
const example = "실제 코드에서 발췌"
```

## 언어

- 사용자가 한국어로 물으면 한국어로 설명
- 사용자가 영어로 물으면 영어로 설명
- 기술 용어는 원어를 유지 (예: "state machine", "threshold", "hit test")

## 입력

- 설명 대상: 파일 경로, 함수명, 개념명, 또는 자연어 설명

## 출력

- 단계별 설명 (한 번에 하나씩)
- 최종 요약
