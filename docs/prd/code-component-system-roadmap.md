# 코드 컴포넌트 시스템 로드맵

## 개요

디자인 에디터의 코드 컴포넌트 시스템을 "장난감 수준"에서 "실제 프로덕션 워크플로우에서 쓸 수 있는 수준"으로 끌어올리기 위한 기능 로드맵.

핵심 가치: **에디터에서 보이는 것이 곧 React 코드** -- 코드 컴포넌트도 이 원칙을 따라야 한다. 사용자가 코드로 만든 컴포넌트가 에디터 안에서 네이티브 노드처럼 자연스럽게 동작하고, 최종적으로 깔끔한 React 코드로 내보내질 수 있어야 한다.

---

## 현재 상태 (AS-IS)

### 할 수 있는 것

- Components 패널에서 TSX 코드 에디터로 컴포넌트 작성
- `propertyControls` export로 props UI 자동 생성
- esbuild-wasm 브라우저 내 실시간 컴파일
- 프리뷰 패널에서 렌더링 확인
- 캔버스에 인스턴스 추가 및 Properties 패널에서 props 편집
- ElementNode 선택 시 Code 탭에서 JSX 코드 확인/복사

### PropertyControl 지원 타입

string, number, boolean, color, enum (총 5개)

---

## 사용자 시나리오 분석

### 시나리오 1: 커스텀 버튼 컴포넌트 만들기

**상황**: 사용자가 프로젝트 전체에서 일관된 버튼 스타일을 쓰고 싶다.

**현재 가능한 흐름**:

1. Components 패널 > "+ New" > Monaco 에디터 열림
2. `Button` 컴포넌트를 TSX로 작성 (label, variant, size 등 props 정의)
3. `propertyControls`로 label(string), variant(enum), disabled(boolean) 등록
4. 프리뷰에서 확인 후 Cmd+S 저장
5. 캔버스에 인스턴스 추가
6. Properties 패널에서 label을 "로그인"으로, variant를 "primary"로 변경

**막히는 지점**:

- 인스턴스를 여러 개 놓고 각각 다른 label을 줬을 때, 이 인스턴스들의 코드를 내보낼 수 없다 (코드 생성 미지원)
- 버튼에 아이콘을 넣고 싶으면 file/image 타입 prop이 없어서 불가능
- onClick 같은 이벤트 핸들러를 prop으로 연결할 수 없다

---

### 시나리오 2: 외부 디자인 시스템 컴포넌트 가져오기

**상황**: 사용자가 이미 사용 중인 MUI/shadcn 컴포넌트를 에디터에서 쓰고 싶다.

**현재 가능한 흐름**:

- 없음. 시작 자체가 불가능.

**막히는 지점**:

- npm 패키지 import가 불가능하다 (보안상 relative import 금지)
- 따라서 외부 라이브러리 컴포넌트를 에디터 안에서 전혀 사용할 수 없다

---

### 시나리오 3: 반복 가능한 카드 리스트 만들기

**상황**: 사용자가 카드 컴포넌트를 만들고, 이를 여러 개 배치해서 리스트 UI를 구성하고 싶다.

**현재 가능한 흐름**:

1. Card 코드 컴포넌트 작성 (title, description, imageUrl 등 props)
2. 캔버스에 인스턴스 3개 추가
3. 각 인스턴스의 props를 개별 편집

**막히는 지점**:

- imageUrl을 string으로만 입력해야 한다 (파일 업로드 UI 없음)
- 카드 안에 children을 넣을 수 없다 (ComponentInstance prop 타입 없음)
- 마스터 컴포넌트를 수정하면 모든 인스턴스에 반영되는지 불명확 (오버라이드 시스템 없음)
- 3개 카드의 코드를 한꺼번에 내보낼 수 없다

---

### 시나리오 4: 디자인을 React 프로젝트에 넘기기

**상황**: 사용자가 에디터에서 만든 디자인을 실제 React 프로젝트로 가져가고 싶다.

**현재 가능한 흐름**:

1. ElementNode를 선택하면 Code 탭에서 JSX 확인 가능
2. 코드를 복사해서 프로젝트에 붙여넣기

**막히는 지점**:

- 코드 컴포넌트 인스턴스의 코드 생성이 안 된다 ("cannot be exported directly")
- TextNode의 코드 생성이 안 된다 ("coming soon")
- 컴포넌트 자체를 .tsx 파일로 export할 수 없다
- 전체 페이지를 하나의 React 컴포넌트로 내보내기 불가

---

### 시나리오 5: 팀 내 컴포넌트 공유

**상황**: 팀원이 만든 컴포넌트를 다른 팀원이 바로 사용하고 싶다.

**현재 가능한 흐름**:

- 없음.

**막히는 지점**:

- 컴포넌트를 export/import하는 메커니즘 자체가 없다
- 공유 라이브러리 개념이 없다
- 이 시나리오는 현 단계에서 우선순위가 낮다 (1인 사용자 시나리오를 먼저 완성해야 함)

---

## 기능 우선순위

### ICE 프레임워크 (Impact / Confidence / Ease, 각 1-10)

| #   | 기능                        | I   | C   | E   | ICE | 순위  |
| --- | --------------------------- | --- | --- | --- | --- | ----- |
| 1   | 인스턴스 코드 생성          | 10  | 9   | 6   | 540 | **1** |
| 2   | TextNode 코드 생성          | 8   | 9   | 7   | 504 | **2** |
| 3   | PropertyControl 타입 확장   | 7   | 8   | 7   | 392 | **3** |
| 4   | 컴포넌트/페이지 파일 export | 8   | 8   | 5   | 320 | **4** |
| 5   | 인스턴스 오버라이드 시스템  | 7   | 7   | 4   | 196 | **5** |
| 6   | npm 패키지 import           | 9   | 7   | 3   | 189 | **6** |
| 7   | 빌트인 컴포넌트 라이브러리  | 6   | 6   | 3   | 108 | **7** |
| 8   | 컴포넌트 버저닝             | 4   | 5   | 4   | 80  | **8** |
| 9   | 공유 컴포넌트 라이브러리    | 5   | 5   | 2   | 50  | **9** |

---

### 기능별 상세

#### 1. 인스턴스 코드 생성 (ICE: 540, 1위)

**무엇인지**: CodeComponentInstance 노드를 선택했을 때, Code 탭에서 해당 컴포넌트의 JSX 사용 코드를 보여주는 것.

**사용자가 뭘 할 수 있게 되는지**: `<Button label="로그인" variant="primary" />` 같은 코드를 Code 탭에서 바로 확인하고 복사할 수 있다.

**왜 지금 해야 하는지**: 이 에디터의 핵심 가치가 "보이는 것 = React 코드"인데, 코드 컴포넌트 인스턴스에서 코드를 볼 수 없다는 것은 핵심 가치를 훼손한다. 사용자가 코드 컴포넌트를 만드는 이유 자체가 결국 React 코드를 얻기 위해서다.

**구현 복잡도**: Medium

- 인스턴스가 참조하는 컴포넌트 이름 + 현재 props 값을 조합하면 JSX를 생성할 수 있다
- codegen 모듈에 CodeComponentInstance 타입 핸들러를 추가하는 작업

---

#### 2. TextNode 코드 생성 (ICE: 504, 2위)

**무엇인지**: TextNode를 선택했을 때 Code 탭에서 해당 텍스트의 JSX/HTML 코드를 보여주는 것.

**사용자가 뭘 할 수 있게 되는지**: 텍스트 노드의 스타일이 적용된 `<span>` 또는 `<p>` 태그 코드를 확인하고 복사할 수 있다.

**왜 지금 해야 하는지**: 텍스트는 모든 UI의 기본 요소다. Frame과 Shape의 코드 생성은 되는데 Text가 안 되면, 실제 페이지 단위 코드 내보내기가 불가능하다. 인스턴스 코드 생성과 함께 해결해야 "전체 코드 내보내기" 시나리오가 완성된다.

**구현 복잡도**: Low-Medium

- TextNode의 content, fontSize, fontWeight, color 등 스타일 속성을 CSS로 변환
- codegen 모듈에 TextNode 타입 핸들러 추가

---

#### 3. PropertyControl 타입 확장 (ICE: 392, 3위)

**무엇인지**: 현재 5개뿐인 PropertyControl 타입에 file, image, array, object, componentInstance, eventHandler 타입을 추가하는 것.

**사용자가 뭘 할 수 있게 되는지**:

- **file/image**: 이미지 업로드 UI로 prop에 이미지 지정 가능
- **array**: 반복 가능한 데이터(태그 목록, 네비게이션 아이템 등)를 prop으로 전달 가능
- **object**: 여러 값을 그룹핑한 prop 정의 가능 (예: `style: { bg, border }`)
- **componentInstance**: 컴포넌트 안에 다른 컴포넌트를 children/slot으로 넣기 가능

**왜 지금 해야 하는지**: 현재 5개 타입으로는 "단순한 버튼" 수준의 컴포넌트만 만들 수 있다. 실용적인 컴포넌트(카드, 리스트, 네비게이션 등)를 만들려면 최소한 image와 array가 필요하다.

**구현 복잡도**: Medium

- 각 타입별 Properties 패널 UI 위젯 구현 필요
- array/object는 중첩 편집 UI가 필요해서 상대적으로 복잡
- 추천 우선순위: image > array > object > componentInstance > eventHandler

---

#### 4. 컴포넌트/페이지 파일 export (ICE: 320, 4위)

**무엇인지**: 코드 컴포넌트를 `.tsx` 파일로 다운로드하거나, 캔버스 전체를 하나의 React 컴포넌트 파일로 내보내는 것.

**사용자가 뭘 할 수 있게 되는지**:

- 에디터에서 만든 컴포넌트를 실제 React 프로젝트에 바로 드롭 가능
- 전체 페이지의 React 코드를 파일로 받아서 프로젝트에 통합 가능

**왜 지금 해야 하는지**: 코드 생성(1, 2번)이 완성되면, 그 코드를 "파일로 가져갈 수 있느냐"가 자연스러운 다음 질문이다. 복사-붙여넣기는 임시방편이고, 파일 export가 진짜 워크플로우다.

**구현 복잡도**: Medium

- 1, 2번 기능에 의존 (코드 생성이 먼저 완성되어야 함)
- 페이지 단위 export는 노드 트리 전체를 재귀적으로 JSX로 변환해야 함
- import 구문 자동 생성 (사용된 코드 컴포넌트의 import 정리)

---

#### 5. 인스턴스 오버라이드 시스템 (ICE: 196, 5위)

**무엇인지**: 마스터 컴포넌트를 수정하면 모든 인스턴스에 반영되되, 인스턴스별로 개별 변경한 props는 유지되는 시스템. Figma의 component override 개념과 유사.

**사용자가 뭘 할 수 있게 되는지**:

- 마스터 Button의 border-radius를 바꾸면 모든 Button 인스턴스에 반영
- 단, 인스턴스 A에서 label을 "로그인"으로 바꾼 것은 유지됨
- "Reset to master" 기능으로 인스턴스의 개별 변경을 되돌릴 수 있음

**왜 지금 해야 하는지**: 현재도 인스턴스별 props 편집은 가능하지만, 마스터 변경 시 어떤 값이 유지되고 어떤 값이 덮어쓰여지는지가 불명확하다. 컴포넌트 수가 늘어나면 이 문제가 두드러진다. 다만, 1-4번보다는 "있으면 좋은" 기능이다.

**구현 복잡도**: High

- 인스턴스별 override 상태 추적 로직 필요
- "이 prop은 사용자가 명시적으로 바꾼 것인가 vs 기본값인가" 판별 필요
- Properties 패널에 override 표시 UI (Figma의 파란 점 같은)

---

#### 6. npm 패키지 import (ICE: 189, 6위)

**무엇인지**: 코드 컴포넌트에서 `import { Button } from "@mui/material"` 같은 외부 패키지 사용을 허용하는 것.

**사용자가 뭘 할 수 있게 되는지**:

- MUI, shadcn, Ant Design 등 기존 디자인 시스템 컴포넌트를 에디터 안에서 사용 가능
- Framer처럼 npm 생태계를 에디터 안으로 가져올 수 있음

**왜 지금 해야 하는지**: 이 기능은 제품의 활용 범위를 크게 넓히지만, 보안/번들링/성능 문제가 복잡하다. Phase 1-2의 기본기를 먼저 다지고 나서 착수하는 것이 합리적이다.

**구현 복잡도**: High

- 보안: 악의적 패키지 실행 방지 (샌드박스 강화)
- 번들링: esbuild-wasm에서 원격 모듈 해석 (esm.sh, skypack 등 CDN 활용 가능)
- 캐싱: 패키지 다운로드 결과 캐싱
- 버전 관리: 패키지 버전 고정 및 충돌 해결
- 참고: [Framer는 npm import를 지원](https://www.framer.com/developers/property-controls)하며, esm.sh 같은 CDN을 활용하면 복잡도를 낮출 수 있다

---

#### 7. 빌트인 컴포넌트 라이브러리 (ICE: 108, 7위)

**무엇인지**: 에디터에 기본 제공되는 UI 컴포넌트 세트 (Button, Input, Card, Modal 등).

**사용자가 뭘 할 수 있게 되는지**: 코드를 작성하지 않고도 바로 사용할 수 있는 기본 컴포넌트가 있다. "빈 캔버스에서 시작하는 막막함"을 줄인다.

**왜 지금 해야 하는지**: 기본기(1-4번)가 없는 상태에서 빌트인 컴포넌트를 만들어도 코드 생성이 안 되면 의미가 반감된다. npm import(6번) 이후에 하면 외부 디자인 시스템을 래핑하는 형태로 구현할 수도 있어 효율적이다.

**구현 복잡도**: Medium-High (컴포넌트 수에 비례)

---

#### 8-9. 컴포넌트 버저닝 / 공유 라이브러리 (ICE: 80, 50)

현 단계에서는 1인 사용자 시나리오를 먼저 완성하는 것이 중요하다. 버저닝과 공유는 멀티 유저/팀 기능으로, 핵심 워크플로우가 완성된 후에 다뤄야 한다.

---

## 실행 계획 (Phases)

### Phase 1: 코드 생성 완성 -- "만든 것을 코드로 볼 수 있다"

**목표**: 에디터의 모든 노드 타입에서 코드를 생성할 수 있게 한다.

| Task | 설명                            | 난이도 |
| ---- | ------------------------------- | ------ |
| 1-1  | CodeComponentInstance 코드 생성 | M      |
| 1-2  | TextNode 코드 생성              | S-M    |
| 1-3  | 코드 생성 테스트 (단위 테스트)  | S      |

**완료 기준**: 캔버스에 어떤 노드를 선택하든 Code 탭에서 유효한 JSX가 표시된다.

**예상 기간**: 1-2주

**의존성**: 없음 (바로 시작 가능)

---

### Phase 2: Props 표현력 확장 -- "실용적인 컴포넌트를 만들 수 있다"

**목표**: PropertyControl 타입을 확장해서 현실적인 컴포넌트를 만들 수 있게 한다.

| Task | 설명                                                   | 난이도 |
| ---- | ------------------------------------------------------ | ------ |
| 2-1  | image PropertyControl 추가 (파일 업로드 UI + URL 생성) | M      |
| 2-2  | array PropertyControl 추가 (반복 입력 UI)              | M      |
| 2-3  | object PropertyControl 추가 (그룹 입력 UI)             | M      |
| 2-4  | 새 타입들의 코드 생성 반영                             | S      |

**완료 기준**: 사용자가 이미지 prop이 있는 카드 컴포넌트, 배열 데이터를 받는 리스트 컴포넌트를 만들고 캔버스에서 편집할 수 있다.

**예상 기간**: 2-3주

**의존성**: Phase 1 (코드 생성 반영을 위해)

---

### Phase 3: Export 워크플로우 -- "만든 것을 프로젝트에 가져갈 수 있다"

**목표**: 에디터의 결과물을 실제 React 프로젝트로 내보낼 수 있게 한다.

| Task | 설명                                                    | 난이도 |
| ---- | ------------------------------------------------------- | ------ |
| 3-1  | 단일 컴포넌트 .tsx 파일 export                          | M      |
| 3-2  | 페이지 전체 React 컴포넌트 export (노드 트리 재귀 변환) | L      |
| 3-3  | import 구문 자동 생성                                   | M      |
| 3-4  | export 결과 프리뷰 (다운로드 전 확인)                   | S      |

**완료 기준**: 사용자가 에디터에서 만든 페이지를 하나의 .tsx 파일로 다운로드하고, 해당 파일이 React 프로젝트에서 바로 렌더링된다.

**예상 기간**: 2-3주

**의존성**: Phase 1 필수, Phase 2 권장

---

### Phase 4: 컴포넌트 심화 -- "컴포넌트를 전문적으로 관리할 수 있다"

**목표**: 마스터/인스턴스 관계를 명확히 하고, 외부 생태계와 연결한다.

| Task | 설명                                                   | 난이도 |
| ---- | ------------------------------------------------------ | ------ |
| 4-1  | 인스턴스 오버라이드 시스템 (override 추적, 리셋 기능)  | L      |
| 4-2  | componentInstance PropertyControl (slot/children 지원) | L      |
| 4-3  | eventHandler PropertyControl (onClick 등 연결)         | M      |
| 4-4  | Properties 패널에 override 상태 표시                   | M      |

**완료 기준**: 마스터 컴포넌트 수정이 인스턴스에 전파되고, 인스턴스별 override가 명확히 표시/관리된다.

**예상 기간**: 3-4주

**의존성**: Phase 2 (PropertyControl 인프라)

---

### Phase 5: 생태계 확장 -- "외부 세계와 연결된다"

**목표**: npm 생태계와 연결하고, 기본 컴포넌트를 제공한다.

| Task | 설명                                                       | 난이도 |
| ---- | ---------------------------------------------------------- | ------ |
| 5-1  | npm 패키지 import 지원 (esm.sh CDN 활용)                   | L      |
| 5-2  | 패키지 캐싱 및 버전 관리                                   | M      |
| 5-3  | 빌트인 컴포넌트 라이브러리 (Button, Input, Card 등 5-10개) | L      |
| 5-4  | 보안 샌드박스 강화                                         | M      |

**완료 기준**: 사용자가 `import { Button } from "@mui/material"` 같은 코드를 작성하고, 에디터에서 렌더링된다.

**예상 기간**: 4-6주

**의존성**: Phase 1-3 완료 권장

---

## Phase 간 관계

```
Phase 1 (코드 생성)
    |
    +---> Phase 2 (Props 확장) ---> Phase 4 (컴포넌트 심화)
    |
    +---> Phase 3 (Export)     ---> Phase 5 (생태계 확장)
```

Phase 1은 모든 후속 Phase의 기반이다. Phase 2/3은 병렬 진행 가능하지만, 2를 먼저 하는 것을 권장한다 (Export할 때 더 풍부한 코드가 나오므로).

---

## 경쟁 제품 참고

### Framer 코드 컴포넌트

- PropertyControl 타입: Color, Image, Number, File, Boolean, Enum, FusedNumber, EventHandler, Transition, ComponentInstance, Array, Object (12개)
- npm import 지원: 번들러가 npm 의존성을 자동 해석
- Code Override: 기존 요소의 동작을 코드로 수정할 수 있는 별도 시스템
- 참고: [Framer Property Controls](https://www.framer.com/developers/property-controls), [Framer Code Overrides](https://www.framer.com/developers/overrides-introduction)

### Figma Code Connect

- 에디터 안에서 코드를 작성하는 것이 아니라, 외부 코드베이스의 컴포넌트를 Figma 컴포넌트에 매핑하는 방식
- 우리 에디터와 접근이 다름 (우리는 에디터 안에서 코드를 작성하고 실행까지 하는 방식)
- 참고: [Figma Code Connect](https://help.figma.com/hc/en-us/articles/23920389749655-Code-Connect)

---

## 결정 근거 요약

1. **Phase 1을 최우선으로**: "코드로 볼 수 없다"는 것이 제품 핵심 가치와 직접 모순. 가장 빠르게 해결해야 할 문제.

2. **Phase 2를 Phase 3보다 앞에**: Export 기능은 코드 생성만 되면 바로 가능하지만, 내보낸 코드의 품질은 Props 표현력에 달려 있다. 빈약한 코드를 내보내는 것보다 풍부한 코드를 내보내는 것이 사용자 경험에 좋다.

3. **npm import를 뒤로**: Impact는 높지만 Ease가 매우 낮다. 보안/번들링/캐싱 등 풀어야 할 문제가 많아서, 기본기가 탄탄해진 후에 착수하는 것이 리스크가 낮다.

4. **공유/버저닝은 제외**: 현재 1인 사용자 시나리오도 완성되지 않은 상태에서 멀티유저 기능을 기획하는 것은 시기상조.
